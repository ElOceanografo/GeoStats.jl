var documenterSearchIndex = {"docs":
[{"location":"about/community.html","page":"Community","title":"Community","text":"Everyone is welcome to join our community in our gitter channel.","category":"page"},{"location":"about/community.html","page":"Community","title":"Community","text":"(Image: gitter)","category":"page"},{"location":"kriging/solver.html#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"kriging/solver.html","page":"Solver","title":"Solver","text":"Kriging estimators are made available for advanced users. Most users will make use of the polyalgorithm Kriging solver:","category":"page"},{"location":"kriging/solver.html","page":"Solver","title":"Solver","text":"Kriging","category":"page"},{"location":"kriging/solver.html#KrigingEstimators.Kriging","page":"Solver","title":"KrigingEstimators.Kriging","text":"Kriging(var₁=>param₁, var₂=>param₂, ...)\n\nA polyalgorithm Kriging estimation solver.\n\nEach pair var=>param specifies the KrigingParam param for the Kriging variable var. In order to avoid boilerplate code, the constructor expects pairs of Symbol and NamedTuple instead.\n\nParameters\n\nvariogram - Variogram model (default to GaussianVariogram())\nmean      - Simple Kriging mean\ndegree    - Universal Kriging degree\ndrifts    - External Drift Kriging drift functions\n\nLatter options override former options. For example, by specifying drifts, the user is telling the algorithm to ignore degree and mean. If no option is specified, Ordinary Kriging is used by default with the variogram only.\n\nminneighbors - Minimum number of neighbors (default to 1)\nmaxneighbors - Maximum number of neighbors (default to nothing)\nneighborhood - Search neighborhood (default to nothing)\ndistance     - Distance used to find nearest neighbors (default to Euclidean())\n\nThe maxneighbors option can be used to perform approximate Kriging with a subset of data points per estimation location. Two neighborhood search methods are available depending on the value of neighborhood:\n\nIf a neighborhood is provided, local Kriging is performed by sliding the neighborhood in the domain.\nIf neighborhood is not provided, the Kriging system is built using maxneighbors nearest neighbors according to a distance.\n\nExamples\n\nSolve the variable :var₁ with Simple Kriging by specifying the mean, and the variable :var₂ with Universal Kriging by specifying the degree and the variogram model.\n\njulia> Kriging(\n  :var₁ => (mean=1.,),\n  :var₂ => (degree=1, variogram=SphericalVariogram(range=20.))\n)\n\nSolve all variables of the problem with the default parameters (i.e. Ordinary Kriging with unit Gaussian variogram):\n\njulia> Kriging()\n\n\n\n\n\n\n\n","category":"type"},{"location":"operations/miscellaneous.html#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"Below is a list of additional geospatial operations.","category":"page"},{"location":"operations/miscellaneous.html#Geometric","page":"Miscellaneous","title":"Geometric","text":"","category":"section"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"GeoStatsBase.split(::Union{AbstractData,AbstractDomain}, ::Real)","category":"page"},{"location":"operations/miscellaneous.html#Base.split-Tuple{Union{AbstractData, AbstractDomain},Real}","page":"Miscellaneous","title":"Base.split","text":"split(object, fraction, [normal])\n\nSplit spatial object into two parts where the first part has a fraction of the elements. Optionally, the split is performed perpendicular to a normal direction.\n\n\n\n\n\n","category":"method"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"using GeoStats # hide\nusing GeoStatsImages # hide\nusing Plots # hide\ngr(format=:png) # hide\n\n𝒟 = geostatsimage(\"Strebelle\")\n\n# 50/50 split perpendicular to (1.,1.)\nS = split(𝒟, 0.5, (1.,1.))\n\nplot(plot(S[1],ms=0.2), plot(S[2],ms=0.2))","category":"page"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"GeoStatsBase.slice","category":"page"},{"location":"operations/miscellaneous.html#GeoStatsBase.slice","page":"Miscellaneous","title":"GeoStatsBase.slice","text":"slice(object, xmin:xmax, ymin:ymax, ...)\n\nSlice spatial object using real coordinate ranges xmin:xmax, ymin:ymax, ...\n\n\n\n\n\n","category":"function"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"using GeoStats # hide\nusing GeoStatsImages # hide\nusing Plots # hide\ngr(format=:png) # hide\n\n# slice image\nI = geostatsimage(\"Strebelle\")\nS = slice(I, 50.5:100.2, 41.7:81.3)\n\np1 = plot(plot(I), plot(S), link=:both)\n\n# slide point set\nP = sample(I, 100)\nS = slice(P, 50.5:150.7, 175.2:250.3)\n\np2 = plot(plot(P), plot(S), link=:both, ms=3)\n\nplot(p1, p2, layout=(2,1))","category":"page"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"uniquecoords","category":"page"},{"location":"operations/miscellaneous.html#GeoStatsBase.uniquecoords","page":"Miscellaneous","title":"GeoStatsBase.uniquecoords","text":"uniquecoords(sdata, agg=Dict())\n\nRetain locations in spatial objects with unique coordinates.\n\nDuplicates of a variable var are aggregated with aggregation function agg[var]. Default aggregation function is mean for continuous variables and first otherwise.\n\n\n\n\n\n","category":"function"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"using GeoStats # hide\n\nΩ = georef((z=[0, 1, 0],), [0. 1. 0.; 0. 0. 0.])\n\nΓ = uniquecoords(Ω)\n\ncoordinates(Γ)","category":"page"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"boundbox","category":"page"},{"location":"operations/miscellaneous.html#GeoStatsBase.boundbox","page":"Miscellaneous","title":"GeoStatsBase.boundbox","text":"boundbox(object)\n\nReturn the minimum axis-aligned bounding rectangle of the spatial object.\n\n\n\n\n\n","category":"function"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"using GeoStats # hide\n\nR = boundbox(RegularGrid(50, 80))\n\nextrema(R)","category":"page"},{"location":"operations/miscellaneous.html#Tabular","page":"Miscellaneous","title":"Tabular","text":"","category":"section"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"trend","category":"page"},{"location":"operations/miscellaneous.html#GeoStatsBase.trend","page":"Miscellaneous","title":"GeoStatsBase.trend","text":"trend(sdata, vars; degree=1)\n\nReturn the deterministic spatial trend for the variables vars in the spatial sdata. Approximate the trend with a polynomial of given degree.\n\n\n\n\n\n","category":"function"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"using GeoStats # hide\nusing Plots # hide\n\n# quadratic + noise\nr = range(-1,stop=1,length=100)\nμ = [x^2 + y^2 for x in r, y in r]\nϵ = 0.1rand(100,100)\n𝒟 = georef((z=μ+ϵ,))\n\nℳ = trend(𝒟, :z, degree=2)\n\nplot(plot(𝒟), plot(ℳ))","category":"page"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"GeoStatsBase.groupby(::AbstractData, ::Symbol)","category":"page"},{"location":"operations/miscellaneous.html#DataFrames.groupby-Tuple{AbstractData,Symbol}","page":"Miscellaneous","title":"DataFrames.groupby","text":"groupby(sdata, var)\n\nPartition spatial data sdata into groups of constant value for spatial variable var.\n\nNotes\n\nMissing values are grouped into a separate group.\n\n\n\n\n\n","category":"method"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"using GeoStats # hide\nusing GeoStatsImages # hide\nusing Plots # hide\ngr(format=:png) # hide\n\n𝒟 = geostatsimage(\"Strebelle\")\n\nℱ = groupby(𝒟, :facies)\n\nplot(plot(ℱ[1],ms=0.2), plot(ℱ[2],ms=0.2))","category":"page"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"GeoStatsBase.hcat(::AbstractData, ::AbstractData)","category":"page"},{"location":"operations/miscellaneous.html#Base.hcat-Tuple{AbstractData,AbstractData}","page":"Miscellaneous","title":"Base.hcat","text":"hcat(A...)\n\nConcatenate along dimension 2.\n\nExamples\n\njulia> a = [1; 2; 3; 4; 5]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> b = [6 7; 8 9; 10 11; 12 13; 14 15]\n5×2 Array{Int64,2}:\n  6   7\n  8   9\n 10  11\n 12  13\n 14  15\n\njulia> hcat(a,b)\n5×3 Array{Int64,2}:\n 1   6   7\n 2   8   9\n 3  10  11\n 4  12  13\n 5  14  15\n\njulia> c = ([1; 2; 3], [4; 5; 6])\n([1, 2, 3], [4, 5, 6])\n\njulia> hcat(c...)\n3×2 Array{Int64,2}:\n 1  4\n 2  5\n 3  6\n\njulia> x = Matrix(undef, 3, 0)  # x = [] would have created an Array{Any, 1}, but need an Array{Any, 2}\n3×0 Array{Any,2}\n\njulia> hcat(x, [1; 2; 3])\n3×1 Array{Any,2}:\n 1\n 2\n 3\n\n\n\n\n\nhcat(𝒮₁, 𝒮₂)\n\nConcatenate spatial data 𝒮₁ and 𝒮₂ horizontally, i.e. concatenate the columns of the underlying table assuming nelms(𝒮₁) == nelms(𝒮₂).\n\n\n\n\n\n","category":"method"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"using GeoStats # hide\n\n𝒟 = georef((z=rand(100,100),))\n\nhcat(𝒟, 𝒟)","category":"page"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"GeoStatsBase.vcat(::AbstractDomain, ::AbstractDomain)\nGeoStatsBase.vcat(::AbstractData, ::AbstractData)","category":"page"},{"location":"operations/miscellaneous.html#Base.vcat-Tuple{AbstractDomain,AbstractDomain}","page":"Miscellaneous","title":"Base.vcat","text":"vcat(𝒟₁, 𝒟₂)\n\nConcatenate spatial domains 𝒟₁ and 𝒟₂ vertically, i.e. concatenate the coordinates into a new point set containing all points.\n\n\n\n\n\n","category":"method"},{"location":"operations/miscellaneous.html#Base.vcat-Tuple{AbstractData,AbstractData}","page":"Miscellaneous","title":"Base.vcat","text":"vcat(𝒮₁, 𝒮₂)\n\nConcatenate spatial data 𝒮₁ and 𝒮₂ vertically, i.e. concatenate the underlying domains and additionally the table of variables.\n\n\n\n\n\n","category":"method"},{"location":"operations/miscellaneous.html","page":"Miscellaneous","title":"Miscellaneous","text":"using GeoStats # hide\n\n𝒟1 = georef((z=rand(100,100),))\n𝒟2 = georef((w=rand(10,10),))\n\nvcat(𝒟1, 𝒟2)","category":"page"},{"location":"variography/empirical.html#Empirical-variograms","page":"Empirical variograms","title":"Empirical variograms","text":"","category":"section"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"An empirical variogram has the form:","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"hatgamma(h) = frac12N(h) sum_(ij) in N(h) (z_i - z_j)^2","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"where N(h) = left(ij) mid x_i - x_j = hright is the set of pairs of locations at a distance h and N(h) is the cardinality of the set. Empirical variograms can be estimated using general distance functions. These can be used in order to for example:","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"Model anisotropy (e.g. ellipsoid distance)\nPerform geostatistical simulation on spherical coordinate systems (e.g. haversine distance)","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"Please see Distances.jl for a complete list of options.","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"Additionally, given two empirical variograms hatgamma_alpha and hatgamma_beta, they can be merged as described in Hoffimann & Zadrozny 2019:","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"hatgamma_alpha+beta(h) =\nfracN_alpha(h) cdot hatgamma_alpha(h) + N_beta(h) cdot hatgamma_beta(h)N_alpha(h) + N_beta(h)","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"merge(::EmpiricalVariogram{D}, ::EmpiricalVariogram{D}) where {D}","category":"page"},{"location":"variography/empirical.html#Base.merge-Union{Tuple{D}, Tuple{EmpiricalVariogram{D},EmpiricalVariogram{D}}} where D","page":"Empirical variograms","title":"Base.merge","text":"merge(γα, γβ)\n\nMerge the empirical variogram γα with the empirical variogram γβ assuming that both variograms have the same number of lags.\n\n\n\n\n\n","category":"method"},{"location":"variography/empirical.html#Variograms","page":"Empirical variograms","title":"Variograms","text":"","category":"section"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"Consider the following image for illustration purposes:","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"using GeoStats #hide\nusing GeoStatsImages\nusing Plots #hide\n\n𝒟 = geostatsimage(\"Gaussian30x10\")\n\nplot(𝒟)","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"EmpiricalVariogram","category":"page"},{"location":"variography/empirical.html#Variography.EmpiricalVariogram","page":"Empirical variograms","title":"Variography.EmpiricalVariogram","text":"EmpiricalVariogram(sdata, var₁, var₂=var₁; [optional parameters])\n\nComputes the empirical (a.k.a. experimental) omnidirectional (cross-)variogram for variables var₁ and var₂ stored in spatial data sdata.\n\nEmpiricalVariogram(partition, var₁, var₂=var₁; [optional parameters])\n\nAlternatively, compute the (cross-)variogram on a partition of the data as described in Hoffimann & Zadrozny 2019.\n\nParameters\n\nnlags    - number of lags (default to 20)\nmaxlag   - maximum lag (default to half of maximum lag of data)\ndistance - custom distance function (default to Euclidean distance)\nalgo     - accumulation algorithm (default to :ball)\n\nAvailable algorithms:\n\n:full - loop over all pairs of points in the data\n:ball - loop over all points inside maximum lag ball\n\nAll implemented algorithms produce the exact same result. The :ball algorithm is considerably faster when the maximum lag is much smaller than the bounding box of the data.\n\nSee also: DirectionalVariogram\n\nReferences\n\nChilès, JP and Delfiner, P. 2012. Geostatistics: Modeling Spatial Uncertainty\nHoffimann, J and Zadrozny, B. 2019. Efficient variography with partition variograms\n\n\n\n\n\n","category":"type"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"γ = EmpiricalVariogram(𝒟, :Z, maxlag=50.)\n\nplot(γ)","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"DirectionalVariogram","category":"page"},{"location":"variography/empirical.html#Variography.DirectionalVariogram","page":"Empirical variograms","title":"Variography.DirectionalVariogram","text":"DirectionalVariogram(direction, sdata, var₁, var₂=var₁; dtol=1e-6, [parameters])\n\nComputes the empirical (cross-)variogram for the variables var₁ and var₂ stored in spatial data sdata along a given direction with band tolerance dtol.\n\nOptional parameters include the parameters for EmpiricalVariogram and the parameters for DirectionPartition.\n\n\n\n\n\n","category":"function"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"γₕ = DirectionalVariogram((1.,0.), 𝒟, :Z, maxlag=50.)\nγᵥ = DirectionalVariogram((0.,1.), 𝒟, :Z, maxlag=50.)\n\nplot(γₕ, label=\"horizontal\")\nplot!(γᵥ, label=\"vertical\")","category":"page"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"PlanarVariogram","category":"page"},{"location":"variography/empirical.html#Variography.PlanarVariogram","page":"Empirical variograms","title":"Variography.PlanarVariogram","text":"PlanarVariogram(normal, sdata, var₁, var₂=var₁; ntol=1e-6, [parameters])\n\nComputes the empirical (cross-)variogram for the variables var₁ and var₂ stored in spatial data sdata along a plane perpendicular to a normal direction with plane tolerance ntol.\n\nOptional parameters include the parameters for EmpiricalVariogram and the parameters for PlanePartition.\n\n\n\n\n\n","category":"function"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"γᵥ = PlanarVariogram((1.,0.), 𝒟, :Z, maxlag=50.)\nγₕ = PlanarVariogram((0.,1.), 𝒟, :Z, maxlag=50.)\n\nplot(γₕ, label=\"horizontal\")\nplot!(γᵥ, label=\"vertical\")","category":"page"},{"location":"variography/empirical.html#Varioplanes","page":"Empirical variograms","title":"Varioplanes","text":"","category":"section"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"EmpiricalVarioplane","category":"page"},{"location":"variography/empirical.html#Variography.EmpiricalVarioplane","page":"Empirical variograms","title":"Variography.EmpiricalVarioplane","text":"EmpiricalVarioplane(sdata, var₁, var₂=var₁;\n                    normal=spheredir(0,0), nangs=50,\n                    ptol=0.5, dtol=0.5, kwargs...)\n\nGiven a normal direction, estimate the (cross-)variogram of variables var₁ and var₂ along all directions in the corresponding plane of variation.\n\nOptionally, specify the tolerance ptol for the PlanePartition the tolerance dtol for the DirectionPartition, the number of angles nangs in the plane, and forward the keyword arguments kwargs to the various EmpiricalVariogram calls.\n\n\n\n\n\n","category":"type"},{"location":"variography/empirical.html","page":"Empirical variograms","title":"Empirical variograms","text":"γ = EmpiricalVarioplane(𝒟, :Z, maxlag=50.)\n\nplot(γ)","category":"page"},{"location":"variography/theoretical.html#Theoretical-variograms","page":"Theoretical variograms","title":"Theoretical variograms","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"In an intrinsic isotropic model, the variogram is only a function of the distance between any two points x_1x_2 in R^m:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(x_1x_2) = gamma(x_1 - x_2) = gamma(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"Under the additional assumption of 2nd-order stationarity, the well-known covariance is directly related via gamma(h) = cov(0) - cov(h). Anisotropic models are easily obtained by defining an ellipsoid distance in place of the Euclidean distance. For a list of available distances, please see Distances.jl.","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"This package implements a few commonly used and other more exotic variogram models. Most of these models share a set of default parameters (e.g. sill=1, range=1, distance=Euclidean()). Some of them have extra parameters that can be set with keyword arguments:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"using GeoStats # hide\nusing Plots # hide\nMaternVariogram(order=1.) # set order of Bessel function","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"Additionally, a nested variogram model gamma(h) = c_1cdotgamma_1(h) + c_2cdotgamma_2(h) + cdots + c_ncdotgamma_n(h) can be constructed from multiple variogram models, including matrix coefficients:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"γ₁ = GaussianVariogram()\nγ₂ = ExponentialVariogram()\n\n# nested model\nγ = [1.0 0.0; 0.0 1.0] * γ₁ + [2.0 0.5; 0.5 3.0] * γ₂","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"The individual structures can be recovered in canonical form with the structures function:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"structures","category":"page"},{"location":"variography/theoretical.html#Variography.structures","page":"Theoretical variograms","title":"Variography.structures","text":"structures(γ)\n\nReturn the individual structures of a (possibly nested) variogram as a tuple. The structures are the total nugget cₒ, and the coefficients (or contributions) cs for the remaining non-trivial structures γs after normalization (i.e. sill=1, nugget=0).\n\n\n\n\n\n","category":"function"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"and the 2nd-order stationarity property can be checked with the isstationary function:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"isstationary","category":"page"},{"location":"variography/theoretical.html#Variography.isstationary","page":"Theoretical variograms","title":"Variography.isstationary","text":"isstationary(γ)\n\nCheck if variogram γ possesses the 2nd-order stationary property.\n\n\n\n\n\n","category":"function"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"Geometric anisotropy can be specified as a distance using the aniso2distance function:","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"aniso2distance","category":"page"},{"location":"variography/theoretical.html#GeoStatsBase.aniso2distance","page":"Theoretical variograms","title":"GeoStatsBase.aniso2distance","text":"aniso2distance(semiaxes, angles; convention=:TaitBryanExtr)\n\nA distance defined by an ellipsoid with given semiaxes and rotation angles.\n\nFor 2D ellipsoids, there are two semiaxes and one rotation angle.\nFor 3D ellipsoids, there are three semiaxes and three rotation angles.\n\nConventions\n\nDifferent rotation conventions can be passed via the convention option:\n\n:TaitBryanExtr => Extrinsic right-handed rotation by the ZXY axes\n:TaitBryanIntr => Intrinsic right-handed rotation by the ZXY axes\n:EulerExtr     => Extrinsic right-handed rotation by the ZXZ axes\n:EulerIntr     => Intrinsic right-handed rotation by the ZXZ axes\n:GSLIB         => GSLIB software rotation convention\n:Leapfrog      => Leapfrog software rotation convention\n:Datamine      => Datamine software rotation convention (fixed to ZXZ axes)\n\nTait-Bryan and Euler conventions expect angles in radians. The other conventions expect them in degrees.\n\nDefault convention is :TaitBryanExtr.\n\nExamples\n\n2D ellipsoid making 45ᵒ with the horizontal axis:\n\njulia> aniso2distance([1.0,0.5], [π/2])\n\n3D ellipsoid rotated by 45ᵒ in the xy plane:\n\njulia> aniso2distance([1.0,0.5,0.5], [π/2,0.0,0.0])\n\n\n\n\n\n","category":"function"},{"location":"variography/theoretical.html#Gaussian","page":"Theoretical variograms","title":"Gaussian","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) left1 - expleft(-3left(frachrright)^2right)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"GaussianVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.GaussianVariogram","page":"Theoretical variograms","title":"Variography.GaussianVariogram","text":"GaussianVariogram(sill=s, range=r, nugget=n, distance=d)\n\nA Gaussian variogram with sill s, range r and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(GaussianVariogram())","category":"page"},{"location":"variography/theoretical.html#Exponential","page":"Theoretical variograms","title":"Exponential","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) left1 - expleft(-3left(frachrright)right)right + n cdot 1_(0infty)(h)\n","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"ExponentialVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.ExponentialVariogram","page":"Theoretical variograms","title":"Variography.ExponentialVariogram","text":"ExponentialVariogram(sill=s, range=r, nugget=n, distance=d)\n\nAn exponential variogram with sill s, range r and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(ExponentialVariogram())","category":"page"},{"location":"variography/theoretical.html#Matern","page":"Theoretical variograms","title":"Matern","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) left1 - frac2^1-nuGamma(nu) left(sqrt2nufrachrright)^nu K_nuleft(sqrt2nufrachrright)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"MaternVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.MaternVariogram","page":"Theoretical variograms","title":"Variography.MaternVariogram","text":"MaternVariogram(sill=s, range=r, nugget=n, order=ν, distance=d)\n\nA Matérn variogram with sill s, range r and nugget n. The parameter ν is the order of the Bessel function. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(MaternVariogram())","category":"page"},{"location":"variography/theoretical.html#Spherical","page":"Theoretical variograms","title":"Spherical","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) leftleft(frac32left(frachrright) + frac12left(frachrright)^3right) cdot 1_(0r)(h) + 1_rinfty)(h)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"SphericalVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.SphericalVariogram","page":"Theoretical variograms","title":"Variography.SphericalVariogram","text":"SphericalVariogram(sill=s, range=r, nugget=n, distance=d)\n\nA spherical variogram with sill s, range r and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(SphericalVariogram())","category":"page"},{"location":"variography/theoretical.html#Cubic","page":"Theoretical variograms","title":"Cubic","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) leftleft(7left(frachrright)^2 - frac354left(frachrright)^3 + frac72left(frachrright)^5 - frac34left(frachrright)^7right) cdot 1_(0r)(h) + 1_rinfty)(h)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"CubicVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.CubicVariogram","page":"Theoretical variograms","title":"Variography.CubicVariogram","text":"CubicVariogram(sill=s, range=r, nugget=n, distance=d)\n\nA cubic variogram with sill s, range r and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(CubicVariogram())","category":"page"},{"location":"variography/theoretical.html#Pentaspherical","page":"Theoretical variograms","title":"Pentaspherical","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) leftleft(frac158left(frachrright) - frac54left(frachrright)^3 + frac38left(frachrright)^5right) cdot 1_(0r)(h) + 1_rinfty)(h)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"PentasphericalVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.PentasphericalVariogram","page":"Theoretical variograms","title":"Variography.PentasphericalVariogram","text":"PentasphericalVariogram(sill=s, range=r, nugget=n, distance=d)\n\nA pentaspherical variogram with sill s, range r and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(PentasphericalVariogram())","category":"page"},{"location":"variography/theoretical.html#Power","page":"Theoretical variograms","title":"Power","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = sh^a + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"PowerVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.PowerVariogram","page":"Theoretical variograms","title":"Variography.PowerVariogram","text":"PowerVariogram(scaling=s, exponent=a, nugget=n, distance=d)\n\nA power variogram with scaling s, exponent a and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(PowerVariogram())","category":"page"},{"location":"variography/theoretical.html#Sine-hole","page":"Theoretical variograms","title":"Sine hole","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) left1 - fracsin(pi h  r)pi h  rright + n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"SineHoleVariogram","category":"page"},{"location":"variography/theoretical.html#Variography.SineHoleVariogram","page":"Theoretical variograms","title":"Variography.SineHoleVariogram","text":"SineHoleVariogram(sill=s, range=r, nugget=n, distance=d)\n\nA sine hole variogram with sill s, range r and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(SineHoleVariogram())","category":"page"},{"location":"variography/theoretical.html#Nugget","page":"Theoretical variograms","title":"Nugget","text":"","category":"section"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = n cdot 1_(0infty)(h)","category":"page"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"NuggetEffect","category":"page"},{"location":"variography/theoretical.html#Variography.NuggetEffect","page":"Theoretical variograms","title":"Variography.NuggetEffect","text":"NuggetEffect(n)\nNuggetEffect(nugget=n, distance=d)\n\nA pure nugget effect variogram with nugget n. Optionally use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"variography/theoretical.html","page":"Theoretical variograms","title":"Theoretical variograms","text":"plot(NuggetEffect(1.0))","category":"page"},{"location":"pointpatterns/pointops.html#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"pointpatterns/pointops.html","page":"Operations","title":"Operations","text":"Below is the list of currently implemented operations for point processes and patterns.","category":"page"},{"location":"pointpatterns/pointops.html#Superposition","page":"Operations","title":"Superposition","text":"","category":"section"},{"location":"pointpatterns/pointops.html","page":"Operations","title":"Operations","text":"The union or (superposition) of two point processes creates a union process:","category":"page"},{"location":"pointpatterns/pointops.html","page":"Operations","title":"Operations","text":"union(::PointProcess, ::PointProcess)","category":"page"},{"location":"pointpatterns/pointops.html#Base.union-Tuple{PointProcess,PointProcess}","page":"Operations","title":"Base.union","text":"p₁ ∪ p₂\n\nUnion (or superposition) of spatial point processes p₁ and p₂.\n\n\n\n\n\n","category":"method"},{"location":"pointpatterns/pointops.html#Thinning","page":"Operations","title":"Thinning","text":"","category":"section"},{"location":"pointpatterns/pointops.html","page":"Operations","title":"Operations","text":"The thin function implements the thinning operation for point processes and patterns. Below are the available thinning methods.","category":"page"},{"location":"pointpatterns/pointops.html","page":"Operations","title":"Operations","text":"thin\nRandomThinning","category":"page"},{"location":"pointpatterns/pointops.html#PointPatterns.thin","page":"Operations","title":"PointPatterns.thin","text":"thin(p, t)\n\nThin spatial point process p with thinning method t.\n\n\n\n\n\nthin(pp, t)\n\nThin spatial point pattern pp with thinning method t.\n\n\n\n\n\n","category":"function"},{"location":"pointpatterns/pointops.html#PointPatterns.RandomThinning","page":"Operations","title":"PointPatterns.RandomThinning","text":"RandomThinning(p)\n\nRandom thining with retention probability p.\n\n\n\n\n\n","category":"type"},{"location":"links.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"links.html","page":"Index","title":"Index","text":"Below is the list of types and functions mentioned in the documentation.","category":"page"},{"location":"links.html#Types","page":"Index","title":"Types","text":"","category":"section"},{"location":"links.html","page":"Index","title":"Index","text":"Order = [:type]","category":"page"},{"location":"links.html#Functions","page":"Index","title":"Functions","text":"","category":"section"},{"location":"links.html","page":"Index","title":"Index","text":"Order = [:function]","category":"page"},{"location":"data.html#Spatial-data","page":"Data","title":"Spatial data","text":"","category":"section"},{"location":"data.html#Overview","page":"Data","title":"Overview","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Given a table or array containing data, we can gereference these objects onto a spatial domain with the georef function. For a list of available spatial domains, please see Domains.","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"georef","category":"page"},{"location":"data.html#GeoStatsBase.georef","page":"Data","title":"GeoStatsBase.georef","text":"georef(table, domain)\n\nGeoreference table on spatial domain.\n\n\n\n\n\ngeoref(table, coords)\n\nGeoreference table on a PointSet(coords).\n\n\n\n\n\ngeoref(table, coordnames)\n\nGeoreference table using columns coordnames.\n\n\n\n\n\ngeoref(tuple, domain)\n\nGeoreference named tuple on spatial domain.\n\n\n\n\n\ngeoref(tuple, coords)\n\nGeorefrence named tuple on PointSet(coords).\n\n\n\n\n\ngeoref(tuple; origin=(0.,0.,...), spacing=(1.,1.,...))\n\nGeoreference named tuple on RegularGrid(size(tuple[1]), origin, spacing).\n\n\n\n\n\n","category":"function"},{"location":"data.html#Examples","page":"Data","title":"Examples","text":"","category":"section"},{"location":"data.html#Tables","page":"Data","title":"Tables","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Consider a table (e.g. DataFrame) with 25 samples of temperature and precipitation:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"using GeoStats #hide\nusing DataFrames\nusing Plots #hide\n\ntable = DataFrame(T=rand(25), P=rand(25))","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"We can georeference this table based on a given set of coordinates:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"𝒟 = georef(table, PointSet(rand(2,25)))\n\nplot(𝒟)","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"or alternatively, georeference it on a 5x5 regular grid (5x5 = 25 samples):","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"𝒟 = georef(table, RegularGrid(5,5))\n\nplot(𝒟)","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"In the first case, the PointSet domain type can be omitted, and GeoStats.jl will understand that the matrix passed as the second argument contains the coordinates of a point set:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"𝒟 = georef(table, rand(2,25))","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"Another common pattern in spatial data sets is when the coordinates of the samples are already part of the table as columns. In this case, we can specify the column names as symbols:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"table = DataFrame(T=rand(25), P=rand(25), X=rand(25), Y=rand(25), Z=rand(25))\n\n𝒟 = georef(table, (:X,:Y,:Z))\n\nplot(𝒟)","category":"page"},{"location":"data.html#Arrays","page":"Data","title":"Arrays","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Consider arrays (e.g. images) with data for various spatial variables. We can georeference these arrays using a named tuple, and GeoStats.jl will understand that the shape of the arrays should be preserved in a regular grid:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"T, P = rand(5,5), rand(5,5)\n\n𝒟 = georef((T=T, P=P))\n\nplot(𝒟)","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"We can also specify the origin and spacing of the grid using keyword arguments:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"𝒟₁ = georef((T=T, P=P), origin=(0.,0.), spacing=(1.,1.))\n𝒟₂ = georef((T=T, P=P), origin=(10.,10.), spacing=(2.,2.))\n\nplot(𝒟₁)\nplot!(𝒟₂)","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"Alternatively, we can interpret the entries of the named tuple as columns in a table:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"𝒟 = georef((T=T, P=T), rand(2,25))\n\nplot(𝒟)","category":"page"},{"location":"data.html#Custom-data","page":"Data","title":"Custom data","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"GeoStats.jl introduces a set of traits that developers can implement to integrate their own spatial data and domain types into the framework. These \"geotraits\" as we call them live in GeoStatsBase.jl.","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"To implement a spatial data type compatible with the project, the developer can inherit basic behavior from GeoStatsBase.AbstractData, and implement two functions:","category":"page"},{"location":"data.html","page":"Data","title":"Data","text":"GeoStatsBase.domain\nGeoStatsBase.values","category":"page"},{"location":"data.html#GeoStatsBase.domain","page":"Data","title":"GeoStatsBase.domain","text":"domain(object)\n\nReturn underlying domain of the object.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Base.values","page":"Data","title":"Base.values","text":"values(object)\n\nReturn the values of object as a table.\n\n\n\n\n\n","category":"function"},{"location":"data.html","page":"Data","title":"Data","text":"The domain function should return the underlying spatial domain of the data. This spatial domain should implement a set of traits for a general finite element mesh. The values function should return a table according to the Tables.jl interface.","category":"page"},{"location":"contributing/solvers.html#Writing-solvers","page":"Writing solvers","title":"Writing solvers","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"After reading this guide, you should be able to write your own geostatistical solver, and enjoy a large set of features for free, including distributed parallel execution, a suite of meta algorithms, and various plot recipes. If you have any questions, please don't hesitate to ask in our gitter channel.","category":"page"},{"location":"contributing/solvers.html#Basics","page":"Writing solvers","title":"Basics","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Currently, there are three types of geostatistical problems defined in the framework:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"EstimationProblem\nSimulationProblem\nLearningProblem","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"The task of writing a solver for a geostatistical problem consists of writing a simple function in Julia that takes the problem as input and returns the solution. In the following sections we illustrate the development process and share working examples that could be copied/pasted as starters.","category":"page"},{"location":"contributing/solvers.html#Writing-estimation-solvers","page":"Writing solvers","title":"Writing estimation solvers","text":"","category":"section"},{"location":"contributing/solvers.html#Create-the-package","page":"Writing solvers","title":"Create the package","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Install the PkgTemplates.jl package and create a new project:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using PkgTemplates\n\ngenerate_interactive(\"MySolver\")","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"This command will create a folder named ~/user/.julia/vx.y/MySolver with all the files that are necessary to load the new package:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using MySolver","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Choose a license for your solver. If you don't have major restrictions, I suggest using the MIT license. Try to choose a permissive license so that your solver can be used, and improved by private corporations.","category":"page"},{"location":"contributing/solvers.html#Import-GeoStatsBase","page":"Writing solvers","title":"Import GeoStatsBase","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"After the package is created, open the main source file MySolver.jl and add the following line:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using GeoStatsBase\nimport GeoStatsBase: solve","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"These lines bring all the symbols defined in GeoStatsBase into scope, and tell Julia that the method solve will be specialized for the new solver. Next, give your solver a name:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"struct MyCoolSolver <: AbstractEstimationSolver\n  # optional parameters go here\nend","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"and export it so that it becomes available to users of your package:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"export MyCoolSolver","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"At this point, the MySolver.jl file should have the following content:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"module MySolver\n\nusing GeoStatsBase\nimport GeoStatsBase: solve\n\nexport MyCoolSolver\n\nstruct MyCoolSolver <: AbstractEstimationSolver\n  # optional parameters go here\nend\n\nend # module","category":"page"},{"location":"contributing/solvers.html#Write-the-algorithm","page":"Writing solvers","title":"Write the algorithm","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Now that your solver type is defined, write your algorithm. Write a function called solve that takes an estimation problem and your solver, and returns an estimation solution:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"function solve(problem::EstimationProblem, solver::MyCoolSolver)\n  pdomain = domain(problem)\n\n  μs = []; σs = []\n  for var in name.(variables(problem))\n    push!(μs, var => rand(nelms(pdomain)))\n    push!(σs, Symbol(var,:Var) => rand(nelms(pdomain)))\n  end\n\n  georef((; μs..., σs...), pdomain)\nend","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Paste this function somewhere in your package, and you are all set.","category":"page"},{"location":"contributing/solvers.html#Test-the-solver","page":"Writing solvers","title":"Test the solver","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"To test your new solver, load the GeoStats.jl package and solve a simple problem:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using GeoStats\nusing MySolver\n\nsdata    = readgeotable(\"samples.csv\", coordnames=(:x,:y))\nsdomain  = RegularGrid(100, 100)\nproblem  = EstimationProblem(sdata, sdomain, :value)\n\nsolution = solve(problem, MyCoolSolver())\n\nplot(solution)","category":"page"},{"location":"contributing/solvers.html#Writing-simulation-solvers","page":"Writing solvers","title":"Writing simulation solvers","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"The process of writing a simulation solver is very similar, but there is an alternative function to solve called solvesingle that is preferred. The function solvesingle takes a simulation problem, one of the variables to be simulated, a solver, and a preprocessed input, and returns a vector with the simulation results:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"function solvesingle(problem::SimulationProblem, covars::NamedTuple,\n                     solver::MySimSolver, preproc)\n  # retrieve problem info\n  pdata = data(problem)\n  pdomain = domain(problem)\n\n  real4var = map(covars.names) do var\n    # output is a single realization for each covariable\n    real = Vector{Float64}(undef, nelms(pdomain))\n\n    # algorithm goes here\n    # ...\n\n    var => real\n  end\n\n  Dict(real4var)\nend","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"This function is preferred over solve if your algorithm is the same for every single realization (the algorithm is only a function of the random seed). In this case, GeoStats.jl will provide an implementation of solve for you that calls solvesingle in parallel.","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"The argument preproc is ignored unless the function preprocess is also defined for the solver. The function takes a simulation problem and a solver, and returns an arbitrary object with preprocessed data:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"preprocess(problem::SimulationProblem, solver::MySimSolver) = nothing","category":"page"},{"location":"contributing/solvers.html#Writing-learning-solvers","page":"Writing solvers","title":"Writing learning solvers","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Similar to the other cases, writing a LearningSolver compatible with the framework consists of writing a simple Julia function that takes the LearningProblem as input along with the solver, and returns spatial data with learned variables.","category":"page"},{"location":"contributing/solvers.html#Examples","page":"Writing solvers","title":"Examples","text":"","category":"section"},{"location":"contributing/solvers.html#Estimation","page":"Writing solvers","title":"Estimation","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"An estimation solver that, for each location of the domain, assigns the 2-norm of the coordinates as the mean and the ∞-norm as the variance.","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using GeoStatsBase\nusing LinearAlgebra: norm\n\n# implement method for new solver\nimport GeoStatsBase: solve\n\n@estimsolver NormSolver begin\n  @param pmean = 2\n  @param pvar  = Inf\nend\n\nfunction solve(problem::EstimationProblem, solver::NormSolver)\n  pdomain = domain(problem)\n\n  # dictionary mapping variable names to types\n  mactypeof = Dict(name(v) => mactype(v) for v in variables(problem))\n\n  # results for each variable\n  μs = []; σs = []\n\n  for covars in covariables(problem, solver)\n    for var in covars.names\n      # get user parameters\n      varparams = covars.params[(var,)]\n\n      # get variable type\n      V = mactypeof[var]\n\n      # allocate memory for result\n      varμ = Vector{V}(undef, nelms(pdomain))\n      varσ = Vector{V}(undef, nelms(pdomain))\n\n      for location in traverse(pdomain, LinearPath())\n        x = coordinates(pdomain, location)\n\n        varμ[location] = norm(x, varparams.pmean)\n        varσ[location] = norm(x, varparams.pvar)\n      end\n\n      push!(μs, var => varμ)\n      push!(σs, Symbol(var,:Var) => varσ)\n    end\n  end\n\n  georef((; μs..., σs...), pdomain)\nend;","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"We can test the newly defined solver on an estimation problem:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using GeoStats\nusing Plots\ngr(size=(900,400)) # hide\n\n# dummy spatial data with a single point and no value\nsdata   = georef((z=[NaN],), reshape([0.,0.], 2, 1))\n\n# estimate on a regular grid\nsdomain = RegularGrid(100, 100)\n\n# the problem to be solved\nproblem = EstimationProblem(sdata, sdomain, :z)\n\n# our new solver\nsolver = NormSolver()\n\nsolution = solve(problem, solver)\n\ncontourf(solution)","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"And assess the behavior of different parameters:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"solver = NormSolver(:z => (pmean=1,pvar=3))\n\nsolution = solve(problem, solver)\n\ncontourf(solution)","category":"page"},{"location":"contributing/solvers.html#Simulation","page":"Writing solvers","title":"Simulation","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"A simulation solver that, for each location of the domain, assigns a random sample from a Gaussian distribution.","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using GeoStatsBase\n\n# implement method for new solver\nimport GeoStatsBase: solvesingle\n\n@simsolver RandSolver begin\n  @param mean = 0\n  @param var  = 1\nend\n\nfunction solvesingle(problem::SimulationProblem, covars::NamedTuple,\n                     solver::RandSolver, preproc)\n  pdomain = domain(problem)\n\n  real4var = map(covars.names) do var\n    # retrieve solver parameters\n    varparams = covars.params[(var,)]\n    μ, σ² = varparams.mean, varparams.var\n\n    # i.i.d. samples ~ Normal(0,1)\n    z = rand(nelms(pdomain))\n\n    # rescale and return\n    var => μ .+ sqrt(σ²) .* z\n  end\n\n  Dict(real4var)\nend;","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"We can test the newly defined solver in a simulation problem:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using GeoStats\nusing Plots\ngr(size=(900,300)) # hide\n\n# simulate on a regular grid\nsdomain = RegularGrid(100, 100)\n\n# the problem to be solved\nproblem = SimulationProblem(sdomain, :z => Float64, 3)\n\n# our new solver\nsolver = RandSolver(:z => (mean=10.,var=10.))\n\nsolution = solve(problem, solver)\n\nheatmap(solution)","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"Note, however, that we did not define the preprocess function for the solver. This function can be used to avoid recalculations for each realization, and to set default parameters for variables that are not explicitly set by users in the solver constructor:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"import GeoStatsBase: preprocess\n\nfunction preprocess(problem::SimulationProblem, solver::RandSolver)\n  preproc = Dict()\n  for covars in covariables(problem, solver)\n    for varname in covars.names\n      varparams = covars.params[(varname,)]\n      preproc[varname] = (mean=varparams.mean, var=varparams.var)\n    end\n  end\n\n  preproc\nend;","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"We can call the preprocess function on problems with multiple variables to check that the solver is producing default values for variables other than the one passed during construction:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"problem = SimulationProblem(sdomain, (:z=>Float64, :w=>Float64), 3)\n\npreprocess(problem, solver)","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"This preproc output is passed by GeoStats.jl as the last argument to the solvesingle function, which could be reimplemented as follows:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"function solvesingle(problem::SimulationProblem, covars::NamedTuple,\n                     solver::RandSolver, preproc)\n  pdomain = domain(problem)\n\n  real4var = map(covars.names) do var\n    # retrieve solver parameters\n    μ, σ² = preproc[var]\n\n    # i.i.d. samples ~ Normal(0,1)\n    z = rand(nelms(pdomain))\n\n    # rescale and return\n    var => μ .+ sqrt(σ²) .* z\n  end\n\n  Dict(real4var)\nend;","category":"page"},{"location":"contributing/solvers.html#Learning","page":"Writing solvers","title":"Learning","text":"","category":"section"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"A learning solver that clusters data into super pixels:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using GeoStatsBase\n\n# implement method for new solver\nimport GeoStatsBase: solvesingle\n\nstruct SLICSolver <: AbstractLearningSolver\n  k::Int # approximate number of super pixels\n  m::Float64 # SLIC tradeoff parameter\nend\n\nfunction solve(problem::LearningProblem, solver::SLICSolver)\n  @assert task(problem) isa ClusteringTask \"invalid problem\"\n\n  # retrieve problem info\n  ptask  = task(problem)\n  feats  = collect(features(ptask))\n  tdata  = targetdata(problem)\n  output = outputvars(ptask)[1]\n\n  # find super pixels\n  slic = SLICPartition(solver.k, solver.m, vars=feats)\n  part = partition(tdata, slic)\n\n  # label for each point in target data\n  labels = Vector{Int}(undef, nelms(tdata))\n  for (i, inds) in enumerate(subsets(part))\n    labels[inds] .= i\n  end\n\n  # return learning solution\n  georef((; output => labels), domain(tdata))\nend;","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"We can test the newly defined solver in a learning problem:","category":"page"},{"location":"contributing/solvers.html","page":"Writing solvers","title":"Writing solvers","text":"using GeoStats\nusing Plots\ngr(size=(900,300)) # hide\n\nΩ = georef((Z=[10sin(i/10) + j for i in 1:100, j in 1:100],))\n\nt = ClusteringTask(:Z, :SUPERPIXEL)\n\np = LearningProblem(Ω, Ω, t)\n\ns = solve(p, SLICSolver(50, 0.01))\n\nplot(plot(Ω), plot(s, c=:viridis))","category":"page"},{"location":"resources/education.html#Education","page":"Education","title":"Education","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"Geostatistics is often misunderstood as \"classical statistics applied to spatial data\". To correct this unfortunate misunderstanding, the best we can do as a community is to list additional learning resources for newcomers. Below is one such a list including related projects with clarifying comments, links to papers, books and video lectures.","category":"page"},{"location":"resources/education.html#Related-projects","page":"Education","title":"Related projects","text":"","category":"section"},{"location":"resources/education.html#GaussianProcesses.jl","page":"Education","title":"GaussianProcesses.jl","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"GaussianProcesses.jl - Gaussian processes (the method) and Simple Kriging are essentially two names for the same concept. The derivation of Kriging estimators, however; does not require distributional assumptions. It is a beautiful coincidence that for multivariate Gaussian distributions, Simple Kriging gives the conditional expectation. Matheron and other important geostatisticians have generalized Gaussian processes to more general random fields with locally-varying mean and for situations where the mean is unknown. GeoStats.jl includes Gaussian processes as a special case as well as other more practical Kriging variants, see the Gaussian processes example.","category":"page"},{"location":"resources/education.html#MLKernels.jl","page":"Education","title":"MLKernels.jl","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"MLKernels.jl - Spatial structure can be represented in many different forms: covariance, variogram, correlogram, etc. Variograms are more general than covariance kernels according to the intrinsic stationary property. This means that there are variogram models with no covariance counterpart. Furthermore, empirical variograms can be easily estimated from the data (in various directions) with an efficient procedure. GeoStats.jl treats variograms as first-class objects, see the Variogram modeling example.","category":"page"},{"location":"resources/education.html#Interpolations.jl","page":"Education","title":"Interpolations.jl","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"Interpolations.jl - Kriging and Spline interpolation have different purposes, yet these two methods are sometimes listed as competing alternatives. Kriging estimation is about minimizing variance (or estimation error), whereas Spline interpolation is about forcedly smooth estimators derived for computer visualization. Kriging is a generalization of Splines in which one has the freedom to customize spatial structure based on data. Besides the estimate itself, Kriging also provides the variance map as a function of knots configuration.","category":"page"},{"location":"resources/education.html#MLJ.jl","page":"Education","title":"MLJ.jl","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"MLJ.jl - Statistical learning theory relies on a set of assumptions that do not hold with spatial data (e.g i.i.d. samples on fixed-size support, stationarity, to name a few). Geostatistical learning theory generalizes traditional machine learning for applications where statistical models need to be learned from spatial data.","category":"page"},{"location":"resources/education.html#Learning-resources","page":"Education","title":"Learning resources","text":"","category":"section"},{"location":"resources/education.html#Books","page":"Education","title":"Books","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"Isaaks, E. and Srivastava, R. 1990. An Introduction to Applied Geostatistics - An introductory book on geostatistics that covers important concepts with very simple language.\nChilès, JP and Delfiner, P. 2012. Geostatistics: Modeling Spatial Uncertainty - An incredible book for those with good mathematical background.","category":"page"},{"location":"resources/education.html#Lectures","page":"Education","title":"Lectures","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"Júlio Hoffimann - Tutorials on geostatistics with the GeoStats.jl project.\nEdward Isaaks - Video lectures on variography, Kriging and related concepts.\nJef Caers - Video lectures on two-point and multiple-point methods.","category":"page"},{"location":"resources/education.html#Related-publications","page":"Education","title":"Related publications","text":"","category":"section"},{"location":"resources/education.html","page":"Education","title":"Education","text":"Below is a list of publications made possible with this project:","category":"page"},{"location":"resources/education.html","page":"Education","title":"Education","text":"Hoffimann, J. & Zadrozny, B. 2019. Efficient Variography with Partition Variograms\nHoffimann et al. 2019. Morphodynamic Analysis and Statistical Synthesis of Geomorphic Data: Application to a Flume Experiment\nBarfod et al. 2017. Hydrostratigraphic Modeling using Multiple-point Statistics and Airbone Transient Electromagnetic Methods\nHoffimann et al. 2017. Stochastic Simulation by Image Quilting of Process-based Geological Models","category":"page"},{"location":"operations/discretizing.html#Discretizing","page":"Discretizing","title":"Discretizing","text":"","category":"section"},{"location":"operations/discretizing.html#Overview","page":"Discretizing","title":"Overview","text":"","category":"section"},{"location":"operations/discretizing.html","page":"Discretizing","title":"Discretizing","text":"Geometries can be discretized:","category":"page"},{"location":"operations/discretizing.html","page":"Discretizing","title":"Discretizing","text":"discretize","category":"page"},{"location":"operations/discretizing.html#GeoStatsBase.discretize","page":"Discretizing","title":"GeoStatsBase.discretize","text":"discretize(region, method)\n\nDiscretize spatial region with discretization method.\n\n\n\n\n\n","category":"function"},{"location":"operations/discretizing.html#Example","page":"Discretizing","title":"Example","text":"","category":"section"},{"location":"operations/discretizing.html","page":"Discretizing","title":"Discretizing","text":"using GeoStats # hide\nusing Plots # hide\ngr(format=:svg) # hide\n\nR = Rectangle((0., 0.), (100., 100.))\n\nD = discretize(R, BlockDiscretization((5, 4)))\n\nplot(D)","category":"page"},{"location":"operations/discretizing.html#Methods","page":"Discretizing","title":"Methods","text":"","category":"section"},{"location":"operations/discretizing.html","page":"Discretizing","title":"Discretizing","text":"BlockDiscretization","category":"page"},{"location":"operations/discretizing.html#GeoStatsBase.BlockDiscretization","page":"Discretizing","title":"GeoStatsBase.BlockDiscretization","text":"BlockDiscretization(dims)\n\nDiscretize spatial region into dims blocks.\n\n\n\n\n\n","category":"type"},{"location":"operations/sampling.html#Sampling","page":"Sampling","title":"Sampling","text":"","category":"section"},{"location":"operations/sampling.html#Overview","page":"Sampling","title":"Overview","text":"","category":"section"},{"location":"operations/sampling.html","page":"Sampling","title":"Sampling","text":"Samples can be drawn from spatial objects:","category":"page"},{"location":"operations/sampling.html","page":"Sampling","title":"Sampling","text":"GeoStatsBase.sample","category":"page"},{"location":"operations/sampling.html#StatsBase.sample","page":"Sampling","title":"StatsBase.sample","text":"sample(object, method)\n\nSample elements from object with method.\n\n\n\n\n\n","category":"function"},{"location":"operations/sampling.html#Example","page":"Sampling","title":"Example","text":"","category":"section"},{"location":"operations/sampling.html","page":"Sampling","title":"Sampling","text":"using GeoStats # hide\nusing LinearAlgebra # hide\nusing Plots # hide\ngr(format=:svg) # hide\n\nΩ = georef((Z=[norm([i,j]) for i in 1:100, j in 1:100],))\n\nS = sample(Ω, 1000, replace=false)\n\nplot(plot(Ω), plot(S))","category":"page"},{"location":"operations/sampling.html#Methods","page":"Sampling","title":"Methods","text":"","category":"section"},{"location":"operations/sampling.html","page":"Sampling","title":"Sampling","text":"UniformSampling\nBallSampling\nWeightedSampling","category":"page"},{"location":"operations/sampling.html#GeoStatsBase.UniformSampling","page":"Sampling","title":"GeoStatsBase.UniformSampling","text":"UniformSampling(size, replace=false)\n\nA method for uniform sampling from spatial objects that produces samples of given size with or without replacement depending on the option replace.\n\n\n\n\n\n","category":"type"},{"location":"operations/sampling.html#GeoStatsBase.BallSampling","page":"Sampling","title":"GeoStatsBase.BallSampling","text":"BallSampling(radius; [options])\n\nA method for sampling isolated points from spatial objects using a ball neighborhood of given radius.\n\nOptions\n\nmetric  - Metric for the ball (default to Euclidean())\nmaxsize - Maximum size of the resulting sample (default to none)\n\n\n\n\n\n","category":"type"},{"location":"operations/sampling.html#GeoStatsBase.WeightedSampling","page":"Sampling","title":"GeoStatsBase.WeightedSampling","text":"WeightedSampling(size, [weights]; replace=false)\n\nA method for weighted sampling from spatial objects that produces samples of given size based on weights with or without replacement depending on the option replace. By default weights are uniform.\n\n\n\n\n\n","category":"type"},{"location":"operations/weighting.html#Weighting","page":"Weighting","title":"Weighting","text":"","category":"section"},{"location":"operations/weighting.html#Overview","page":"Weighting","title":"Overview","text":"","category":"section"},{"location":"operations/weighting.html","page":"Weighting","title":"Weighting","text":"Points or samples in spatial objects can be weighted:","category":"page"},{"location":"operations/weighting.html","page":"Weighting","title":"Weighting","text":"weight","category":"page"},{"location":"operations/weighting.html#GeoStatsBase.weight","page":"Weighting","title":"GeoStatsBase.weight","text":"weight(object, method)\n\nWeight spatial object with method.\n\n\n\n\n\n","category":"function"},{"location":"operations/weighting.html#Example","page":"Weighting","title":"Example","text":"","category":"section"},{"location":"operations/weighting.html","page":"Weighting","title":"Weighting","text":"using GeoStats # hide\nusing LinearAlgebra # hide\nusing Plots # hide\ngr(format=:svg) # hide\n\nΩ = PointSet(rand(2,500))\n\nW = weight(Ω, BlockWeighting(0.1,0.1))\n\nplot(W)","category":"page"},{"location":"operations/weighting.html#Methods","page":"Weighting","title":"Methods","text":"","category":"section"},{"location":"operations/weighting.html","page":"Weighting","title":"Weighting","text":"BlockWeighting\nDensityRatioWeighting","category":"page"},{"location":"operations/weighting.html#GeoStatsBase.BlockWeighting","page":"Weighting","title":"GeoStatsBase.BlockWeighting","text":"BlockWeighting(sides)\nBlockWeighting(side₁, side₂, ...)\n\nA weighting method that assigns weights to points in spatial object based on blocks of given sides. The number n of points inside a block determines the weights 1/n of these points.\n\n\n\n\n\n","category":"type"},{"location":"operations/weighting.html#GeoStatsBase.DensityRatioWeighting","page":"Weighting","title":"GeoStatsBase.DensityRatioWeighting","text":"DensityRatioWeighting(tdata, [vars]; [options])\n\nDensity ratio weights based on empirical distribution of variables in target data tdata. Default to all variables.\n\nOptional parameters\n\nestimator - Density ratio estimator (default to LSIF())\noptlib    - Optimization library (default to default_optlib(estimator))\n\nNotes\n\nEstimators from DensityRatioEstimation.jl are supported.\n\n\n\n\n\n","category":"type"},{"location":"about/license.html","page":"License","title":"License","text":"The GeoStats.jl project is licensed under the MIT license:","category":"page"},{"location":"about/license.html","page":"License","title":"License","text":"MIT License\n\nCopyright (c) 2015 Júlio Hoffimann <julio.hoffimann@gmail.com> and contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","category":"page"},{"location":"pointpatterns/pointprocs.html#Processes","page":"Processes","title":"Processes","text":"","category":"section"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"Point processes can be simulated with the function rand on different geometries:","category":"page"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"rand(::PointProcess, ::AbstractGeometry, ::Int)","category":"page"},{"location":"pointpatterns/pointprocs.html#Base.rand-Tuple{PointProcess,AbstractGeometry,Int64}","page":"Processes","title":"Base.rand","text":"rand(p, r, n=1; [algo])\n\nGenerate n realizations of spatial point process p inside spatial region r. Optionally specify sampling algorithm algo.\n\n\n\n\n\n","category":"method"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"For example, a Poisson process with given intensity in a rectangular region:","category":"page"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"using GeoStats # hide\nusing Plots # hide\ngr(format=:svg) # hide\n\np = PoissonProcess(0.1)\nr = Rectangle((0.,0.), (100.,100.))\n\ns = rand(p, r, 2)\n\nplot(plot(s[1]), plot(s[2]))","category":"page"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"or the superposition of two Binomial processes:","category":"page"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"p₁ = BinomialProcess(50)\np₂ = BinomialProcess(50)\np  = p₁ ∪ p₂ # 100 points\n\ns = rand(p, r, 2)\n\nplot(plot(s[1]), plot(s[2]))","category":"page"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"The homogeneity property of a point process can be checked with the ishomogeneous function:","category":"page"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"ishomogeneous","category":"page"},{"location":"pointpatterns/pointprocs.html#PointPatterns.ishomogeneous","page":"Processes","title":"PointPatterns.ishomogeneous","text":"ishomogeneous(p)\n\nTells whether or not the spatial point process p is homogeneous.\n\n\n\n\n\n","category":"function"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"Below is the list of currently implemented point processes.","category":"page"},{"location":"pointpatterns/pointprocs.html#BinomialProcess","page":"Processes","title":"BinomialProcess","text":"","category":"section"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"BinomialProcess","category":"page"},{"location":"pointpatterns/pointprocs.html#PointPatterns.BinomialProcess","page":"Processes","title":"PointPatterns.BinomialProcess","text":"BinomialProcess(n)\n\nA Binomial point process with n points.\n\n\n\n\n\n","category":"type"},{"location":"pointpatterns/pointprocs.html#PoissonProcess","page":"Processes","title":"PoissonProcess","text":"","category":"section"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"PoissonProcess","category":"page"},{"location":"pointpatterns/pointprocs.html#PointPatterns.PoissonProcess","page":"Processes","title":"PointPatterns.PoissonProcess","text":"PoissonProcess(λ)\n\nA Poisson process with intensity λ.\n\n\n\n\n\n","category":"type"},{"location":"pointpatterns/pointprocs.html#UnionProcess","page":"Processes","title":"UnionProcess","text":"","category":"section"},{"location":"pointpatterns/pointprocs.html","page":"Processes","title":"Processes","text":"UnionProcess","category":"page"},{"location":"pointpatterns/pointprocs.html#PointPatterns.UnionProcess","page":"Processes","title":"PointPatterns.UnionProcess","text":"UnionProcess(p₁, p₂)\n\nUnion (or superposition) of spatial point processes p₁ and p₂.\n\n\n\n\n\n","category":"type"},{"location":"domains.html#Domains","page":"Domains","title":"Domains","text":"","category":"section"},{"location":"domains.html","page":"Domains","title":"Domains","text":"Below is the list of currently implemented domain types.","category":"page"},{"location":"domains.html#PointSet","page":"Domains","title":"PointSet","text":"","category":"section"},{"location":"domains.html","page":"Domains","title":"Domains","text":"PointSet","category":"page"},{"location":"domains.html#GeoStatsBase.PointSet","page":"Domains","title":"GeoStatsBase.PointSet","text":"PointSet(coords)\n\nA set of points with coordinates coords. Each point is represented by a static vector or tuple. Alternatively, coords can be a matrix where the number of rows equals the number of dimensions.\n\nExamples\n\nCreate a 2D point set with 100 points:\n\njulia> PointSet(rand(2,100))\n\nOr equivalently, using a vector of tuples:\n\njulia> PointSet([(rand(),rand()) for i in 1:100])\n\n\n\n\n\n","category":"type"},{"location":"domains.html","page":"Domains","title":"Domains","text":"using GeoStats # hide\nusing Plots # hide\ngr(size=(600,600)) # hide\n\nplot(PointSet(rand(3,100)), camera=(30,60))","category":"page"},{"location":"domains.html#RegularGrid","page":"Domains","title":"RegularGrid","text":"","category":"section"},{"location":"domains.html","page":"Domains","title":"Domains","text":"RegularGrid","category":"page"},{"location":"domains.html#GeoStatsBase.RegularGrid","page":"Domains","title":"GeoStatsBase.RegularGrid","text":"RegularGrid(dims, origin, spacing)\n\nA regular grid with dimensions dims, lower left corner at origin and cell spacing spacing. The three arguments must have the same length.\n\nRegularGrid(start, finish, dims=dims)\n\nAlternatively, construct a regular grid from a start point (lower left) to a finish point (upper right).\n\nRegularGrid{T}(dims)\nRegularGrid{T}(dim1, dim2, ...)\n\nFinally, a regular grid can be constructed by only passing the dimensions dims as a tuple, or by passing each dimension dim1, dim2, ... separately. In this case, the origin and spacing default to (0,0,...) and (1,1,...).\n\nExamples\n\nCreate a 3D grid with 100x100x50 locations:\n\njulia> RegularGrid(100,100,50)\n\nCreate a 2D grid with 100x100 locations and origin at (10.,20.) units:\n\njulia> RegularGrid((100,100),(10.,20.),(1.,1.))\n\nCreate a 1D grid from -1 to 1 with 100 locations:\n\njulia> RegularGrid((-1.,),(1.,), dims=(100,))\n\n\n\n\n\n","category":"type"},{"location":"domains.html","page":"Domains","title":"Domains","text":"plot(RegularGrid(10,10,10), camera=(30,60))","category":"page"},{"location":"domains.html#StructuredGrid","page":"Domains","title":"StructuredGrid","text":"","category":"section"},{"location":"domains.html","page":"Domains","title":"Domains","text":"StructuredGrid","category":"page"},{"location":"domains.html#GeoStatsBase.StructuredGrid","page":"Domains","title":"GeoStatsBase.StructuredGrid","text":"StructuredGrid(X, Y, Z, ...)\n\nA structured grid with coordinates X, Y, Z, ...\n\nExamples\n\nA 2D structured grid can be constructed from coordinates stored in 2D matrices. For example, we can georeference locations in the Earth surface using LAT and LON coordinates:\n\njulia> StructuredGrid(LAT, LON)\n\n\n\n\n\n","category":"type"},{"location":"domains.html","page":"Domains","title":"Domains","text":"# create 3D coordinates\nnx, ny, nz = 20, 10, 5\nX = [x for x in range(0,10,length=nx), j in 1:ny, k in 1:nz]\nY = sin.(X) .+ [0.5j for i in 1:nx, j in 1:ny, k in 1:nz]\nZ = [1.0(k-1) for i in 1:nx, j in 1:ny, k in 1:nz]\n\ng = StructuredGrid(X, Y, Z)\n\nplot(g, camera=(30,60))","category":"page"},{"location":"solvers.html#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"If you are a developer and your solver is not listed below, please open a pull request and we will be happy to review and add it to the list. Please check the developer guide for instructions on how to write your own solvers.","category":"page"},{"location":"solvers.html#Estimation","page":"Solvers","title":"Estimation","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Solver Coverage Description References\nKriging (Image: ) Kriging (SK, OK, UK, EDK) Matheron 1971\nIDW (Image: ) Inverse distance weighting Shepard 1968\nLWR (Image: ) Locally weighted regression Cleveland 1979","category":"page"},{"location":"solvers.html#Simulation","page":"Solvers","title":"Simulation","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"All simulation solvers can generate realizations in parallel unless otherwise noted.","category":"page"},{"location":"solvers.html#Two-point","page":"Solvers","title":"Two-point","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Solver Coverage Description References\nLUGS (Image: ) LU Gaussian simulation Alabert 1987\nSGS (Image: ) Sequential Gaussian simulation Gómez-Hernández 1993\nFFTGS (Image: ) FFT Gaussian simulation Gutjahr 1997","category":"page"},{"location":"solvers.html#Multiple-point","page":"Solvers","title":"Multiple-point","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Solver Coverage Description References\nIQ (Image: ) Image quilting Hoffimann 2017\nTPS (Image: ) Turing patterns Turing 1952","category":"page"},{"location":"solvers.html#Meta","page":"Solvers","title":"Meta","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Solver Coverage Description References\nStratSim (Image: ) Stratigraphy simulation Hoffimann 2018\nCookieCutter (Image: ) Cookie-cutter simulation Begg 1992","category":"page"},{"location":"solvers.html#Learning","page":"Solvers","title":"Learning","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Solver Coverage Description References\nPointwiseLearn (Image: ) Pointwise learning Hoffimann 2018","category":"page"},{"location":"operations/partitioning.html#Partitioning","page":"Partitioning","title":"Partitioning","text":"","category":"section"},{"location":"operations/partitioning.html#Overview","page":"Partitioning","title":"Overview","text":"","category":"section"},{"location":"operations/partitioning.html","page":"Partitioning","title":"Partitioning","text":"A spatial object can be partitioned into various sub-objects:","category":"page"},{"location":"operations/partitioning.html","page":"Partitioning","title":"Partitioning","text":"GeoStatsBase.partition","category":"page"},{"location":"operations/partitioning.html#GeoStatsBase.partition","page":"Partitioning","title":"GeoStatsBase.partition","text":"partition(object, method)\n\nPartition object with partition method.\n\n\n\n\n\n","category":"function"},{"location":"operations/partitioning.html#Example","page":"Partitioning","title":"Example","text":"","category":"section"},{"location":"operations/partitioning.html","page":"Partitioning","title":"Partitioning","text":"using GeoStats # hide\nusing LinearAlgebra # hide\nusing Plots # hide\ngr(format=:png) # hide\n\nΩ = georef((Z=[norm([i,j]) for i in 1:100, j in 1:100],))\n\nΠ = partition(Ω, BlockPartition(10.,10.))\n\nplot(plot(Ω), plot(Π))","category":"page"},{"location":"operations/partitioning.html#Methods","page":"Partitioning","title":"Methods","text":"","category":"section"},{"location":"operations/partitioning.html","page":"Partitioning","title":"Partitioning","text":"RandomPartition\nFractionPartition\nSLICPartition\nBlockPartition\nBisectPointPartition\nBisectFractionPartition\nBallPartition\nPlanePartition\nDirectionPartition\nVariablePartition\nPredicatePartition\nSPredicatePartition\nProductPartition\nHierarchicalPartition","category":"page"},{"location":"operations/partitioning.html#GeoStatsBase.RandomPartition","page":"Partitioning","title":"GeoStatsBase.RandomPartition","text":"RandomPartition(k, [shuffle])\n\nA method for partitioning spatial data uniformly into k subsets of approximately equal size. Optionally shuffle the data (default to true).\n\n\n\n\n\n","category":"type"},{"location":"operations/partitioning.html#GeoStatsBase.FractionPartition","page":"Partitioning","title":"GeoStatsBase.FractionPartition","text":"FractionPartition(fraction, shuffle=true)\n\nA method for partitioning spatial objects according to a given fraction. Optionally shuffle elements before partitioning.\n\n\n\n\n\n","category":"type"},{"location":"operations/partitioning.html#GeoStatsBase.SLICPartition","page":"Partitioning","title":"GeoStatsBase.SLICPartition","text":"SLICPartition(k, m; tol=1e-4, maxiter=10, vars=nothing)\n\nA method for partitioning spatial data into approximately k clusters using Simple Linear Iterative Clustering (SLIC). The method produces clusters of samples that are spatially connected based on a distance dₛ and that, at the same time, are similar in terms of vars with distance dᵥ. The tradeoff is controlled with a hyperparameter parameter m in an additive model dₜ = √(dᵥ² + m²(dₛ/s)²).\n\nParameters\n\nk       - Approximate number of clusters\nm       - Hyperparameter of SLIC model\ntol     - Tolerance of k-means algorithm (default to 1e-4)\nmaxiter - Maximum number of iterations (default to 10)\nvars    - Variables (or features) to consider (default to all)\n\nReferences\n\nAchanta et al. 2011. SLIC superpixels compared to state-of-the-art superpixel methods\n\n\n\n\n\n","category":"type"},{"location":"operations/partitioning.html#GeoStatsBase.BlockPartition","page":"Partitioning","title":"GeoStatsBase.BlockPartition","text":"BlockPartition(sides)\nBlockPartition(side₁, side₂, ...)\n\nA method for partitioning spatial objects into blocks of given sides.\n\n\n\n\n\n","category":"type"},{"location":"operations/partitioning.html#GeoStatsBase.BisectPointPartition","page":"Partitioning","title":"GeoStatsBase.BisectPointPartition","text":"BisectPointPartition(normal, point)\n\nA method for partitioning spatial data into two half spaces defined by a normal direction and a reference point.\n\n\n\n\n\n","category":"type"},{"location":"operations/partitioning.html#GeoStatsBase.BisectFractionPartition","page":"Partitioning","title":"GeoStatsBase.BisectFractionPartition","text":"BisectFractionPartition(normal, fraction=0.5, maxiter=10)\n\nA method for partitioning spatial data into two half spaces defined by a normal direction and a fraction of points. The partition is returned within maxiter bisection iterations.\n\n\n\n\n\n","category":"type"},{"location":"operations/partitioning.html#GeoStatsBase.BallPartition","page":"Partitioning","title":"GeoStatsBase.BallPartition","text":"BallPartition(radius; metric=Euclidean())\n\nA method for partitioning spatial objects into balls of a given radius using a metric.\n\n\n\n\n\n","category":"type"},{"location":"operations/partitioning.html#GeoStatsBase.PlanePartition","page":"Partitioning","title":"GeoStatsBase.PlanePartition","text":"PlanePartition(normal; tol=1e-6)\n\nA method for partitioning spatial data into a family of hyperplanes defined by a normal direction. Two points x and y belong to the same hyperplane when (x - y) ⋅ normal < tol.\n\n\n\n\n\n","category":"type"},{"location":"operations/partitioning.html#GeoStatsBase.DirectionPartition","page":"Partitioning","title":"GeoStatsBase.DirectionPartition","text":"DirectionPartition(direction; tol=1e-6)\n\nA method for partitioning spatial objects along a given direction with bandwidth tolerance tol.\n\n\n\n\n\n","category":"type"},{"location":"operations/partitioning.html#GeoStatsBase.VariablePartition","page":"Partitioning","title":"GeoStatsBase.VariablePartition","text":"VariablePartition(var)\n\nA method for partitioning spatial data into subsets of constant value for variable var.\n\n\n\n\n\n","category":"type"},{"location":"operations/partitioning.html#GeoStatsBase.PredicatePartition","page":"Partitioning","title":"GeoStatsBase.PredicatePartition","text":"PredicatePartition(pred)\n\nA method for partitioning spatial objects with a given predicate function pred(i, j).\n\n\n\n\n\n","category":"type"},{"location":"operations/partitioning.html#GeoStatsBase.SPredicatePartition","page":"Partitioning","title":"GeoStatsBase.SPredicatePartition","text":"SPredicatePartition(pred)\n\nA method for partitioning spatial objects with a given spatial predicate function pred(x, y).\n\n\n\n\n\n","category":"type"},{"location":"operations/partitioning.html#GeoStatsBase.ProductPartition","page":"Partitioning","title":"GeoStatsBase.ProductPartition","text":"ProductPartition(p₁, p₂)\n\nA method for partitioning spatial objects using the product of two partitioners p₁ and p₂.\n\n\n\n\n\n","category":"type"},{"location":"operations/partitioning.html#GeoStatsBase.HierarchicalPartition","page":"Partitioning","title":"GeoStatsBase.HierarchicalPartition","text":"HierarchicalPartition(first, second)\n\nA partitioning method in which a first partition is applied and then a second partition is applied to each subset of the first.\n\n\n\n\n\n","category":"type"},{"location":"contributing/guidelines.html#Guidelines","page":"Guidelines","title":"Guidelines","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"First off, thank you for considering contributing to GeoStats.jl. It’s people like you that make this project so much fun. Below are a few suggestions to speed up the collaboration process:","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"Please be polite, we are here to help and learn from each other.\nTry to explain your contribution with simple language.\nReferences to textbooks and papers are always welcome.\nFollow the coding standards in the source.","category":"page"},{"location":"contributing/guidelines.html#Reporting-issues","page":"Guidelines","title":"Reporting issues","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"If you are experiencing issues or have discovered a bug, please report it on GitHub. To make the resolution process easier, please include the version of Julia and GeoStats.jl in your writeup. These can be found with two commands:","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"julia> versioninfo()\njulia> using Pkg; Pkg.status()","category":"page"},{"location":"contributing/guidelines.html#Feature-requests","page":"Guidelines","title":"Feature requests","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"If you have suggestions of improvement or algorithms that you would like to see implemented in GeoStats.jl, please open an issue on GitHub. Suggestions as well as feature requests are very welcome.","category":"page"},{"location":"contributing/guidelines.html#Code-contribution","page":"Guidelines","title":"Code contribution","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"If you have code that you would like to contribute to GeoStats.jl, that is awesome! Please open an issue before you create the pull request on GitHub so that we make sure your idea is aligned with our goals for the project.","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"After your idea is discussed and revised by maintainers, please get the development version of the project by typing the following in the package manager:","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"] activate @geo","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"This will create a fresh environment called @geo where you can play with the project components without compromising your normal user environment.","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"] dev GeoStatsBase Variography KrigingEstimators GeoEstimation GaussianSimulation PointPatterns GeoStats","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"This will clone all the project components in your ~/.julia folder so that you can modify it and submit a pull request on GitHub later. Don't hesitate to ask questions in our gitter channel if you are not familiar with the Git workflow. We are looking forward to your contributions.","category":"page"},{"location":"operations/searching.html#Searching","page":"Searching","title":"Searching","text":"","category":"section"},{"location":"operations/searching.html#Overview","page":"Searching","title":"Overview","text":"","category":"section"},{"location":"operations/searching.html","page":"Searching","title":"Searching","text":"Neighbors of a point or sample can be searched efficiently:","category":"page"},{"location":"operations/searching.html","page":"Searching","title":"Searching","text":"search","category":"page"},{"location":"operations/searching.html#GeoStatsBase.search","page":"Searching","title":"GeoStatsBase.search","text":"search(xₒ, method, mask=nothing)\n\nReturn neighbors of coordinates xₒ using method and a mask over the spatial object.\n\n\n\n\n\n","category":"function"},{"location":"operations/searching.html#Example","page":"Searching","title":"Example","text":"","category":"section"},{"location":"operations/searching.html","page":"Searching","title":"Searching","text":"using GeoStats # hide\nusing LinearAlgebra # hide\nusing Plots # hide\ngr(format=:svg) # hide\n\nΩ = georef((Z=[norm([i,j]) for i in 1:100, j in 1:100],))\n\n# construct searcher\nb = BallNeighborhood(20.)\ns = NeighborhoodSearch(Ω, b)\n\n# query neighbors of point\ninds = search([50.,50.], s)\n𝒩 = view(Ω, inds)\n\np₁ = plot(Ω)\np₂ = plot(𝒩, lims=(0,100))\n\nplot(p₁, p₂)","category":"page"},{"location":"operations/searching.html#Methods","page":"Searching","title":"Methods","text":"","category":"section"},{"location":"operations/searching.html","page":"Searching","title":"Searching","text":"NeighborhoodSearch\nKNearestSearch\nKBallSearch\nBoundedSearch","category":"page"},{"location":"operations/searching.html#GeoStatsBase.NeighborhoodSearch","page":"Searching","title":"GeoStatsBase.NeighborhoodSearch","text":"NeighborhoodSearch(object, neighborhood)\n\nA method for searching neighbors in spatial object inside neighborhood.\n\n\n\n\n\n","category":"type"},{"location":"operations/searching.html#GeoStatsBase.KNearestSearch","page":"Searching","title":"GeoStatsBase.KNearestSearch","text":"KNearestSearch(object, k; metric=Euclidean())\n\nA method for searching k nearest neighbors in spatial object according to metric.\n\n\n\n\n\n","category":"type"},{"location":"operations/searching.html#GeoStatsBase.KBallSearch","page":"Searching","title":"GeoStatsBase.KBallSearch","text":"KBallSearch(object, k, ball)\n\nA method that searches k nearest neighbors and then filters these neighbors using a norm ball.\n\n\n\n\n\n","category":"type"},{"location":"operations/searching.html#GeoStatsBase.BoundedSearch","page":"Searching","title":"GeoStatsBase.BoundedSearch","text":"BoundedSearch(method, nmax)\n\nA method for searching at most nmax neighbors using method.\n\n\n\n\n\n","category":"type"},{"location":"variography/fitting.html#Fitting-variograms","page":"Fitting variograms","title":"Fitting variograms","text":"","category":"section"},{"location":"variography/fitting.html#Overview","page":"Fitting variograms","title":"Overview","text":"","category":"section"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"Fitting theoretical variograms to empirical observations is an important modeling step to ensure valid mathematical models of spatial continuity. Given an empirical variogram, the fit function can be used to perform the fit:","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"fit(::Type{Variogram}, ::EmpiricalVariogram, ::VariogramFitAlgo)","category":"page"},{"location":"variography/fitting.html#StatsBase.fit-Tuple{Type{Variogram},EmpiricalVariogram,VariogramFitAlgo}","page":"Fitting variograms","title":"StatsBase.fit","text":"fit(V, γ, [algo])\n\nFit theoretical variogram type V to empirical variogram γ using algorithm algo. Default algorithm is WeightedLeastSquares.\n\n\n\n\n\nfit(Variogram, γ, [algo])\n\nFit all subtypes of Variogram to empirical variogram γ and return the one with minimum error as defined by the algorithm algo.\n\n\n\n\n\n","category":"method"},{"location":"variography/fitting.html#Example","page":"Fitting variograms","title":"Example","text":"","category":"section"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"using GeoStats # hide\nusing Plots # hide\n\n# sinusoidal data\n𝒟 = georef((Z=[sin(i/2) + sin(j/2) for i in 1:50, j in 1:50],))\n\n# empirical variogram\ng = EmpiricalVariogram(𝒟, :Z, maxlag=25.)\n\nplot(g)","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"We can fit specific models to the empirical variogram:","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"γ = fit(SineHoleVariogram, g)\n\nplot(g)\nplot!(γ)","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"or let GeoStats.jl find the model with minimum error:","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"γ = fit(Variogram, g)\n\nplot(g)\nplot!(γ)","category":"page"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"which should be a SineHoleVariogram given that the synthetic data of this example is sinusoidal.","category":"page"},{"location":"variography/fitting.html#Methods","page":"Fitting variograms","title":"Methods","text":"","category":"section"},{"location":"variography/fitting.html#Weighted-least-squares","page":"Fitting variograms","title":"Weighted least squares","text":"","category":"section"},{"location":"variography/fitting.html","page":"Fitting variograms","title":"Fitting variograms","text":"WeightedLeastSquares","category":"page"},{"location":"variography/fitting.html#Variography.WeightedLeastSquares","page":"Fitting variograms","title":"Variography.WeightedLeastSquares","text":"WeightedLeastSquares()\nWeightedLeastSquares(w)\n\nFit theoretical variogram using weighted least squares with weighting function w (e.g. h -> 1/h). If no weighting function is provided, bin counts of empirical variogram are normalized and used as weights.\n\n\n\n\n\n","category":"type"},{"location":"resources/fileformats.html#File-formats","page":"File formats","title":"File formats","text":"","category":"section"},{"location":"resources/fileformats.html","page":"File formats","title":"File formats","text":"The Julia ecosystem provides various packages for reading/writing spatial data:","category":"page"},{"location":"resources/fileformats.html","page":"File formats","title":"File formats","text":"File format Package\nNetCDF NCDatasets.jl\nGRIB GRIB.jl\nGDAL ArchGDAL.jl\nGSLIB GslibIO.jl\nShapefile Shapefile.jl\nGeoPackage ArchGDAL.jl\nGeoJSON GeoJSON.jl","category":"page"},{"location":"problems.html#Problems","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"The project provides solutions to three types of problems defined below.","category":"page"},{"location":"problems.html#Estimation","page":"Problems","title":"Estimation","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"EstimationProblem","category":"page"},{"location":"problems.html#GeoStatsBase.EstimationProblem","page":"Problems","title":"GeoStatsBase.EstimationProblem","text":"EstimationProblem(sdata, sdomain, vars)\n\nA spatial estimation problem on a given spatial domain sdomain in which the variables to be estimated are listed in vars. The data of the problem is stored in spatial data sdata.\n\nExamples\n\nCreate an estimation problem for precipitation measurements:\n\njulia> EstimationProblem(sdata, sdomain, :precipitation)\n\nCreate an estimation problem for precipitation and CO₂:\n\njulia> EstimationProblem(sdata, sdomain, (:precipitation,:CO₂))\n\n\n\n\n\n","category":"type"},{"location":"problems.html#Example","page":"Problems","title":"Example","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"Define a 2D estimation problem:","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"using GeoStats # hide\nusing Plots # hide\nusing Distances # hide\ngr(size=(900,400),clabels=true) # hide\n\n# list of properties with coordinates\nprops = (Z=[1.,0.,1.],)\ncoord = [(25.,25.), (50.,75.), (75.,50.)]\n\n# estimation problem\n𝒟 = georef(props, coord)\n𝒢 = RegularGrid(100, 100)\n𝒫 = EstimationProblem(𝒟, 𝒢, :Z)","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"Solve the problem with a few built-in solvers:","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"# few built-in solvers\nS1 = IDW(:Z => (distance=Euclidean(),))\nS2 = IDW(:Z => (distance=Chebyshev(),))\nS3 = Kriging(:Z => (variogram=GaussianVariogram(range=35.),))\n\n# solve the problem\nsol = [solve(𝒫, S) for S in (S1, S2, S3)]\n\n# plot the solution\ncontourf(sol[1])","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"contourf(sol[2])","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"contourf(sol[3])","category":"page"},{"location":"problems.html#Simulation","page":"Problems","title":"Simulation","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"SimulationProblem","category":"page"},{"location":"problems.html#GeoStatsBase.SimulationProblem","page":"Problems","title":"GeoStatsBase.SimulationProblem","text":"SimulationProblem(sdata, sdomain, vars, nreals)\nSimulationProblem(sdomain, vars, nreals)\n\nA spatial simulation problem on a given spatial domain sdomain in which the variables to be simulated are listed in vars.\n\nFor conditional simulation, the data of the problem is stored in spatial data sdata.\n\nFor unconditional simulation, a list of pairs vars must be provided mapping variable names to their types.\n\nIn both cases, a number nreals of realizations is requested.\n\nExamples\n\nCreate a conditional simulation problem for porosity and permeability with 100 realizations:\n\njulia> SimulationProblem(sdata, sdomain, (:porosity,:permeability), 100)\n\nCreate an unconditional simulation problem for porosity and facies type with 100 realizations:\n\njulia> SimulationProblem(sdomain, (:porosity => Float64, :facies => Int), 100)\n\n\n\n\n\n","category":"type"},{"location":"problems.html#Example-2","page":"Problems","title":"Example","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"Define a 2D unconditional simulation problem:","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"using GeoStats # hide\nusing Plots # hide\ngr(size=(900,300)) # hide\n\n# unconditional simulation problem\n𝒢 = RegularGrid(100, 100)\n𝒫 = SimulationProblem(𝒢, :Z => Float64, 3)","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"Solve the problem with a few built-in solvers:","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"# few built-in solvers\nS1 = LUGS(:Z => (variogram=GaussianVariogram(range=25.),))\nS2 = FFTGS(:Z => (variogram=GaussianVariogram(range=25.),))\n\n# solve the problem\nsol = [solve(𝒫, S) for S in (S1, S2)]\n\n# plot the solution\nheatmap(sol[1])","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"heatmap(sol[2])","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"Alternatively, define a 2D conditional simulation problem:","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"# unconditional realization\nZ1 = sol[1][1]\n\n# sample observations\n𝒟 = sample(Z1, 10, replace=false)\n\n# conditional simulation problem\n𝒫 = SimulationProblem(𝒟, 𝒢, :Z, 3)","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"And solve it as before:","category":"page"},{"location":"problems.html","page":"Problems","title":"Problems","text":"# solve the problem\nsol = solve(𝒫, S1)\n\n# plot the solution\nheatmap(sol)","category":"page"},{"location":"problems.html#Learning","page":"Problems","title":"Learning","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"LearningProblem","category":"page"},{"location":"problems.html#GeoStatsBase.LearningProblem","page":"Problems","title":"GeoStatsBase.LearningProblem","text":"LearningProblem(sdata, tdata, task)\n\nA spatial learning problem with source data sdata, target data tdata, and learning task.\n\nExamples\n\nCreate a clustering problem based on a set of soil features:\n\njulia> LearningProblem(sdata, tdata,\n                       ClusteringTask((:moisture,:mineral)))\n\n\n\n\n\n","category":"type"},{"location":"problems.html#Example-3","page":"Problems","title":"Example","text":"","category":"section"},{"location":"problems.html","page":"Problems","title":"Problems","text":"Please consult the Basic workflow for an example.","category":"page"},{"location":"workflow.html#Basic-workflow","page":"Basic workflow","title":"Basic workflow","text":"","category":"section"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"A basic geostatistical workflow often consists of three steps:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Manipulation of spatial data\nDefinition of geostatistical problem\nVisualization of problem solution","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"In this section, we walk through these steps to illustrate some of the features of the project.","category":"page"},{"location":"workflow.html#Manipulating-data","page":"Basic workflow","title":"Manipulating data","text":"","category":"section"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"The workflow starts with the creation of spatial data objects, which can be loaded from disk or derived from other Julia variables. For example, given a Julia array (or image), which is not attached to any particular coordinate system:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"using Plots\ngr(format=:svg) # hide\n\nZ = [10sin(i/10) + j for i in 1:100, j in 1:200]\n\nheatmap(Z)","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"We can georeference the image using the georef function:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"using GeoStats\n\nΩ = georef((Z=Z,))","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"The origin and spacing of samples in the image can be specified with:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"georef((Z=Z,), origin=(1.,1.), spacing=(10.,10.))","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"and different spatial configurations can be obtained with different methods (see Data).","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"We plot the spatial data and note a few differences compared to the image plot shown above:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"plot(Ω)","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"First, we note that the image was rotated to match the first index i of the array with the horizontal \"x\" axis, and the second index j of the array with the vertical \"y\" axis. Second, we note that the image was stretched to reflect the real 100x200 size of the regular grid data.","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Each sample in the spatial data object has a coordinate, which is calculated on demand for a given list of locations (i.e. spatial indices):","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"coordinates(Ω, 1:3)","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"In-place versions exist to avoid unnecessary memory allocations.","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"All coordinates are retrieved as a matrix when we do not specify the spatial indices:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"coordinates(Ω)","category":"page"},{"location":"workflow.html#Tabular-access","page":"Basic workflow","title":"Tabular access","text":"","category":"section"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Spatial data types implement the Tables.jl interface, which means that they can be accessed as if they were tables with samples in the rows and variables in the columns. This interface is convenient to pass spatial data to non-spatial workflows directly.","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Additionaly, we can access the values of a variable as a vector using the variable name:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Ω[:Z]","category":"page"},{"location":"workflow.html#Spatial-views","page":"Basic workflow","title":"Spatial views","text":"","category":"section"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Spatial data types can be viewed at a subset of locations without unnecessary memory allocations. Spatial views do not preserve the spatial regularity of the data in general.","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"By plotting a view of the first 10 lines of our image data, we obtain a general point set as opposed to a regular grid configuration:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Ωᵥ = view(Ω, 1:10*100)\nplot(Ωᵥ)","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"We plot a random view of the grid to emphasize that views do not preserve spatial regularity:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"inds = rand(1:nelms(Ω), 100)\nplot(view(Ω, inds))","category":"page"},{"location":"workflow.html#Data-partitions","page":"Basic workflow","title":"Data partitions","text":"","category":"section"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Spatial data objects can be partitioned with various efficient methods. To demonstrate the operation, we partition our spatial data view into balls of given radius:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Π = partition(Ωᵥ, BallPartition(5.))\nplot(Π)","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"or, alternatively, into two halfspaces:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Π = partition(Ωᵥ, BisectFractionPartition((1.,1.), 0.5))\nplot(Π)","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Spatial partitions are (lazy) iterators of spatial views, which are useful in many contexts as it will be shown in the next section. To access a subset of a partition, we use index notation:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"plot(Π[1])","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"plot(Π[2])","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Various other spatial operations are defined in the framework besides partitioning. For a complete list, please check the Operations section of the reference guide.","category":"page"},{"location":"workflow.html#Defining-problems","page":"Basic workflow","title":"Defining problems","text":"","category":"section"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Having defined the spatial data objects, we proceed and define the geostatistical problem to be solved. In this guide, we illustrate geostatistical learning. For other types of geostatistical problems, please check the Problems section of the documentation.","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Let's assume that we have spatial data with some variable that we want to predict in a supervised learning setting. We load the data from a CSV file, and inspect the available columns:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"using CSV\nusing DataFrames\ngr(size=(800,400)) # hide\n\ndf = DataFrame(CSV.File(\"data/agriculture.csv\"))\n\nfirst(df, 5)","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Columns band1, ..., band4 represent four satellite bands for different locations (x,y) in this spatial region. The column crop has the crop type for each location that was labeled manually with the purpose of training a learning model.","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Because the labels are categorical variables, we need to inform the framework the correct type:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"DataFrames.transform!(df, :crop => categorical => :crop)\n\nfirst(df, 5)","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"We can now georeference the table and plot some of the spatial variables:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Ω = georef(df, (:x,:y))\n\ngr(format=:png) # hide\nplot(Ω, (:band4,:crop), ms=0.2, mc=:viridis)","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Similar to a generic statistical learning workflow, we split the data into \"train\" and \"test\" sets. The main difference here is that our spatial split function accepts a separating plane specified by its normal direction (1,-1):","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Ωs, Ωt = split(Ω, 0.2, (1.,-1.))\n\nplot(domain(Ωs), ms=0.2)\nplot!(domain(Ωt), ms=0.2, mc=:green)","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"We can visualize the domain of the \"train\" (or source) set Ωs in black, and the domain of the \"test\" (or target) set Ωt in green. We reserved 20% of the samples to Ωs and 80% to Ωt. Internally, this spatial split function is implemented in terms of efficient spatial partitioning operations, which were illustrated in the previous section.","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Let's define the learning task and the geostatistical learning problem. We want to predict the crop type based on the four satellite bands. We will train the model in Ωs where labels are available, and apply it to Ωt, which is our target:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"feats = [:band1,:band2,:band3,:band4]\nlabel = :crop\n\n𝒯 = ClassificationTask(feats, label)\n\n𝒫 = LearningProblem(Ωs, Ωt, 𝒯)","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"GeoStats.jl is integrated with the MLJ.jl project, which means that we can solve geostatistical learning problems with any classical learning model:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"using MLJ\n\nℳ = @load DecisionTreeClassifier\n\nℒ = PointwiseLearn(ℳ)","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"In this example, we selected a PointwiseLearn strategy to solve the geostatistical learning problem. This strategy consists of applying the learning model pointwise for every point in the spatial data:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Ω̂t = solve(𝒫, ℒ)","category":"page"},{"location":"workflow.html#Plotting-solutions","page":"Basic workflow","title":"Plotting solutions","text":"","category":"section"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"We note that the solution to a geostatistical learning problem is a spatial data object, and we can inspect it with the same methods already described above. This also means that we can plot the solution directly, side by side with the true label in this synthetic example:","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"p̂ = plot(Ω̂t, ms=0.2, mc=:viridis, title=\"crop (prediction)\")\np = plot(Ωt, (:crop,), ms=0.2, mc=:viridis)\n\nplot(p̂, p)","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"Visually, the learning model has succeeded predicting the crop. We can also estimate the generalization error of the geostatistical solver with spatial validation methods such as block cross-validation and leave-ball-out, but these methods deserve a separate tutorial.","category":"page"},{"location":"workflow.html","page":"Basic workflow","title":"Basic workflow","text":"With this example we conclude the basic workflow. To get familiar with other features of the project, please check the tutorials and the reference guide.","category":"page"},{"location":"validation.html#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"GeoStats.jl was designed to, among other things, facilitate rigorous scientific comparison of different geostatistical solvers in the literature. As a user of geostatistics, you may be interested in applying various solvers on a given data set and pick the ones with best performance. As a researcher in the field, you may be interested in benchmarking your new method against other established methods.","category":"page"},{"location":"validation.html","page":"Validation","title":"Validation","text":"Errors of geostatistical solvers can be estimated on given geostatistical problems:","category":"page"},{"location":"validation.html","page":"Validation","title":"Validation","text":"GeoStatsBase.error","category":"page"},{"location":"validation.html#Base.error","page":"Validation","title":"Base.error","text":"error(solver, problem, method)\n\nEstimate error of solver in a given problem with error estimation method.\n\n\n\n\n\n","category":"function"},{"location":"validation.html","page":"Validation","title":"Validation","text":"Below is the list of currently implemented error estimation methods.","category":"page"},{"location":"validation.html#Leave-one-out-validation","page":"Validation","title":"Leave-one-out validation","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"LeaveOneOut","category":"page"},{"location":"validation.html#GeoStatsBase.LeaveOneOut","page":"Validation","title":"GeoStatsBase.LeaveOneOut","text":"LeaveOneOut(; loss=Dict())\n\nLeave-one-out validation. Optionally, specify loss function from LossFunctions.jl for some of the variables.\n\nReferences\n\nStone. 1974. Cross-Validatory Choice and Assessment of Statistical Predictions\n\n\n\n\n\n","category":"type"},{"location":"validation.html#Leave-ball-out-validation","page":"Validation","title":"Leave-ball-out validation","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"LeaveBallOut","category":"page"},{"location":"validation.html#GeoStatsBase.LeaveBallOut","page":"Validation","title":"GeoStatsBase.LeaveBallOut","text":"LeaveBallOut(ball; loss=Dict())\n\nLeave-ball-out (a.k.a. spatial leave-one-out) validation. Optionally, specify loss function from LossFunctions.jl for some of the variables.\n\nLeaveBallOut(radius; loss=Dict())\n\nBy default, use Euclidean ball of given radius in space.\n\nReferences\n\nLe Rest et al. 2014. Spatial leave-one-out cross-validation for variable selection in the presence of spatial autocorrelation\n\n\n\n\n\n","category":"type"},{"location":"validation.html#Cross-validation","page":"Validation","title":"Cross-validation","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"CrossValidation","category":"page"},{"location":"validation.html#GeoStatsBase.CrossValidation","page":"Validation","title":"GeoStatsBase.CrossValidation","text":"CrossValidation(k; shuffle=true, loss=Dict())\n\nk-fold cross-validation. Optionally, shuffle the data, and specify loss function  from LossFunctions.jl for some of the variables.\n\nReferences\n\nGeisser, S. 1975. The predictive sample reuse method with applications\nBurman, P. 1989. A comparative study of ordinary cross-validation, v-fold cross-validation and the repeated learning-testing methods\n\n\n\n\n\n","category":"type"},{"location":"validation.html#Block-cross-validation","page":"Validation","title":"Block cross-validation","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"BlockCrossValidation","category":"page"},{"location":"validation.html#GeoStatsBase.BlockCrossValidation","page":"Validation","title":"GeoStatsBase.BlockCrossValidation","text":"BlockCrossValidation(sides; loss=Dict())\n\nCross-validation with blocks of given sides. Optionally, specify loss function from LossFunctions.jl for some of the variables. If only one side is provided, then blocks become cubes.\n\nReferences\n\nRoberts et al. 2017. Cross-validation strategies for data with temporal, spatial, hierarchical, or phylogenetic structure\nPohjankukka et al. 2017. Estimating the prediction performance of spatial models via spatial k-fold cross-validation\n\n\n\n\n\n","category":"type"},{"location":"validation.html#Weighted-cross-validation","page":"Validation","title":"Weighted cross-validation","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"WeightedCrossValidation","category":"page"},{"location":"validation.html#GeoStatsBase.WeightedCrossValidation","page":"Validation","title":"GeoStatsBase.WeightedCrossValidation","text":"WeightedCrossValidation(weigthing, folding; lambda=1.0, loss=Dict())\n\nAn error estimation method which samples are weighted with weighting method and split into folds with folding method. Weights are raised to lambda power in [0,1]. Optionally, specify loss function from LossFunctions.jl for some of the variables.\n\nReferences\n\nSugiyama et al. 2006. Importance-weighted cross-validation for covariate shift\nSugiyama et al. 2007. Covariate shift adaptation by importance weighted cross validation\n\n\n\n\n\n","category":"type"},{"location":"validation.html#Density-ratio-validation","page":"Validation","title":"Density-ratio validation","text":"","category":"section"},{"location":"validation.html","page":"Validation","title":"Validation","text":"DensityRatioValidation","category":"page"},{"location":"validation.html#GeoStatsBase.DensityRatioValidation","page":"Validation","title":"GeoStatsBase.DensityRatioValidation","text":"DensityRatioValidation(k; [parameters])\n\nDesntity ratio validation where weights are first obtained with density ratio estimation, and then used in k-fold weighted cross-validation.\n\nParameters\n\nshuffle   - Shuffle the data before folding (default to true)\nestimator - Density ratio estimator (default to LSIF())\noptlib    - Optimization library (default to default_optlib(estimator))\nlambda    - Power of density ratios (default to 1.0)\n\nPlease see DensityRatioEstimation.jl for a list of supported estimators.\n\nReferences\n\nHoffimann et al. 2020. Geostatistical Learning: Challenges and Opportunities\n\n\n\n\n\n","category":"type"},{"location":"plotting.html#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"Most objects defined in the project can be plotted directly without major efforts. Other plots are provided below that can be useful for spatial data analysis.","category":"page"},{"location":"plotting.html#hscatter","page":"Plotting","title":"hscatter","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"A hscatter plot between two variables var1 and var2 (possibly with var2 = var1) is a simple scatter plot in which the dots represent all ordered pairs of values of var1 and var2 at a given lag h.","category":"page"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"using GeoStats\nusing Plots\ngr(size=(800,300)) # hide\n\n𝒟 = georef((Z=[10sin(i/10) + j for i in 1:100, j in 1:200],))\n\n𝒮 = sample(𝒟, 500)\n\np1 = hscatter(𝒮, :Z, lag=0)\np2 = hscatter(𝒮, :Z, lag=20)\np3 = hscatter(𝒮, :Z, lag=40)\np4 = hscatter(𝒮, :Z, lag=60)\n\nplot(p1, p2, p3, p4)","category":"page"},{"location":"plotting.html#distplot1d","page":"Plotting","title":"distplot1d","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"A distplot1d of a variable var displays the adjusted spatial histogram (see EmpiricalHistogram), and optionally a list of quantiles.","category":"page"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"z = randn(500)\n\n𝒮 = georef((Z=z,))\n\ndistplot1d(𝒮, :Z, quantiles=[0.25,0.50,0.75])","category":"page"},{"location":"plotting.html#distplot2d","page":"Plotting","title":"distplot2d","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"A distplot2d of two variables var1 and var2 displays the 2D histogram, and optionally a list of quantiles.","category":"page"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"z1 = randn(500)\nz2 = z1 + randn(500)\n\n𝒮 = georef((Z1=z1, Z2=z2))\n\ndistplot2d(𝒮, :Z1, :Z2, quantiles=[0.25,0.50,0.75])","category":"page"},{"location":"plotting.html#cornerplot","page":"Plotting","title":"cornerplot","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"A cornerplot displays a grid of plots with distplot1d plots in the diagonal and distplot2d in the off-diagonal entries of the grid.","category":"page"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"z1 = randn(500)\nz2 = z1 + randn(500)\n\n𝒮 = georef((Z1=z1, Z2=z2))\n\ncornerplot(𝒮, (:Z1,:Z2), quantiles=[0.25,0.50,0.75])","category":"page"},{"location":"kriging/estimators.html#Estimators","page":"Estimators","title":"Estimators","text":"","category":"section"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"A Kriging estimator has the form:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"hatZ(x_0) = lambda_1 Z(x_1) + lambda_2 Z(x_2) + cdots + lambda_n Z(x_n)quad x_i in R^m lambda_i in R","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"with Zcolon R^m times Omega to R a random field.","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"This package implements the following Kriging variants:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"Simple Kriging\nOrdinary Kriging\nUniversal Kriging\nExternal Drift Kriging","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"All these variants follow the same interface: an estimator object is first created with a given set of parameters (e.g. estimator = OrdinaryKriging(γ)), it is then combined with the data krig = fit(estimator, X, z) to obtain predictions at new locations predict(krig, xₒ).","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"The fit function takes care of building the Kriging system and factorizing the LHS with an appropriate decomposition (e.g. Cholesky, LU):","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"KrigingEstimators.fit","category":"page"},{"location":"kriging/estimators.html#StatsBase.fit","page":"Estimators","title":"StatsBase.fit","text":"fit(estimator, X, z)\n\nFit estimator to coordinates X and values z, and return a fitted estimator.\n\n\n\n\n\n","category":"function"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"The predict function performs the estimation at a given location:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"KrigingEstimators.predict","category":"page"},{"location":"kriging/estimators.html#GeoStatsBase.predict","page":"Estimators","title":"GeoStatsBase.predict","text":"predict(estimator, xₒ)\n\nPredict with the estimator at coordinates xₒ.\n\n\n\n\n\n","category":"function"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"Alternative constructors are provided for convenience that will immediately fit the Kriging parameters to the data. In this case, the data is passed as the first argument. For example:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"OrdinaryKriging(X, z, γ)","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"creates a OrdinaryKriging(γ) estimator and fits it to (X,z).","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"A typical use of the interface is as follows:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"# build and factorize the system\nsk = SimpleKriging(X, z, γ, mean(z))\n\n# estimate at various locations\nfor xₒ in [x₁, x₂, x₃]\n  μ, σ² = predict(sk, xₒ)\nend","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"For advanced users, the Kriging weights and Lagrange multipliers at a given location can be accessed with the weights method. This method returns a KrigingWeights object containing a field λ for the weights and a field ν for the Lagrange multipliers:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"weights","category":"page"},{"location":"kriging/estimators.html#KrigingEstimators.weights","page":"Estimators","title":"KrigingEstimators.weights","text":"weights(estimator, xₒ)\n\nCompute the weights λ (and Lagrange multipliers ν) for the estimator at coordinates xₒ.\n\n\n\n\n\n","category":"function"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"For example with Ordinary Kriging:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"ok = OrdinaryKriging(X, z, γ)\nw = weights(ok, xₒ)\nw.λ, w.ν","category":"page"},{"location":"kriging/estimators.html#Simple-Kriging","page":"Estimators","title":"Simple Kriging","text":"","category":"section"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"In Simple Kriging, the mean mu of the random field is assumed to be constant and known. The resulting linear system is:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"beginbmatrix\ncov(x_1x_1)  cov(x_1x_2)  cdots  cov(x_1x_n) \ncov(x_2x_1)  cov(x_2x_2)  cdots  cov(x_2x_n) \nvdots  vdots  ddots  vdots \ncov(x_nx_1)  cov(x_nx_2)  cdots  cov(x_nx_n)\nendbmatrix\nbeginbmatrix\nlambda_1 \nlambda_2 \nvdots \nlambda_n\nendbmatrix\n=\nbeginbmatrix\ncov(x_1x_0) \ncov(x_2x_0) \nvdots \ncov(x_nx_0)\nendbmatrix","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"or in matricial form Cl = c. We subtract the given mean from the observations boldsymboly = z - mu 1 and compute the mean and variance at location x_0:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"mu(x_0) = mu + boldsymboly^top l","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"sigma^2(x_0) = cov(0) - c^top l","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"SimpleKriging","category":"page"},{"location":"kriging/estimators.html#KrigingEstimators.SimpleKriging","page":"Estimators","title":"KrigingEstimators.SimpleKriging","text":"SimpleKriging(γ, μ)\nSimpleKriging(X, z, γ, μ)\n\nSimple Kriging with variogram model γ and constant mean μ.\n\nOptionally, pass the coordinates X and values z to the fit function.\n\nNotes\n\nSimple Kriging requires stationary variograms\n\n\n\n\n\n","category":"type"},{"location":"kriging/estimators.html#Ordinary-Kriging","page":"Estimators","title":"Ordinary Kriging","text":"","category":"section"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"In Ordinary Kriging the mean of the random field is assumed to be constant and unknown. The resulting linear system is:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"beginbmatrix\nG  1 \n1^top  0\nendbmatrix\nbeginbmatrix\nl \nnu\nendbmatrix\n=\nbeginbmatrix\ng \n1\nendbmatrix","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"with nu the Lagrange multiplier associated with the constraint 1^top l = 1. The mean and variance at location x_0 are given by:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"mu(x_0) = z^top l","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"sigma^2(x_0) =  beginbmatrix g  1 endbmatrix^top beginbmatrix l  nu endbmatrix","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"OrdinaryKriging","category":"page"},{"location":"kriging/estimators.html#KrigingEstimators.OrdinaryKriging","page":"Estimators","title":"KrigingEstimators.OrdinaryKriging","text":"OrdinaryKriging(γ)\nOrdinaryKriging(X, z, γ)\n\nOrdinary Kriging with variogram model γ.\n\nOptionally, pass the coordinates X and values z to the fit function.\n\n\n\n\n\n","category":"type"},{"location":"kriging/estimators.html#Universal-Kriging","page":"Estimators","title":"Universal Kriging","text":"","category":"section"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"In Universal Kriging, the mean of the random field is assumed to be a polynomial of the spatial coordinates:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"mu(x) = sum_k=1^N_d beta_k f_k(x)","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"with N_d monomials f_k of degree up to d. For example, in 2D there are 6 monomials of degree up to 2:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"mu(x_1x_2) =  beta_1 1 + beta_2 x_1 + beta_3 x_2 + beta_4 x_1 x_2 + beta_5 x_1^2 + beta_6 x_2^2","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"The choice of the degree d determines the size of the polynomial matrix","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"F =\nbeginbmatrix\nf_1(x_1)  f_2(x_1)  cdots  f_N_d(x_1) \nf_1(x_2)  f_2(x_2)  cdots  f_N_d(x_2) \nvdots  vdots  ddots  vdots \nf_1(x_n)  f_2(x_n)  cdots  f_N_d(x_n)\nendbmatrix","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"and polynomial vector f = beginbmatrix f_1(x_0)  f_2(x_0)  cdots  f_N_d(x_0) endbmatrix^top.","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"The variogram determines the variogram matrix:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"G =\nbeginbmatrix\ngamma(x_1x_1)  gamma(x_1x_2)  cdots  gamma(x_1x_n) \ngamma(x_2x_1)  gamma(x_2x_2)  cdots  gamma(x_2x_n) \nvdots  vdots  ddots  vdots \ngamma(x_nx_1)  gamma(x_nx_2)  cdots  gamma(x_nx_n)\nendbmatrix","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"and the variogram vector g = beginbmatrix gamma(x_1x_0)  gamma(x_2x_0)  cdots  gamma(x_nx_0) endbmatrix^top.","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"The resulting linear system is:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"beginbmatrix\nG  F \nF^top  boldsymbol0\nendbmatrix\nbeginbmatrix\nl \nboldsymbolnu\nendbmatrix\n=\nbeginbmatrix\ng \nf\nendbmatrix","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"with boldsymbolnu the Lagrange multipliers associated with the universal constraints. The mean and variance at location x_0 are given by:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"mu(x_0) = z^top l","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"sigma^2(x_0) = beginbmatrixg  fendbmatrix^top beginbmatrixl  boldsymbolnuendbmatrix","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"UniversalKriging","category":"page"},{"location":"kriging/estimators.html#KrigingEstimators.UniversalKriging","page":"Estimators","title":"KrigingEstimators.UniversalKriging","text":"UniversalKriging(γ, degree, dim)\nUniversalKriging(X, z, γ, degree)\n\nUniversal Kriging with variogram model γ and polynomial degree on a spatial domain of dimension dim.\n\nOptionally, pass the coordinates X and values z to the fit function.\n\nNotes\n\nOrdinaryKriging is recovered for 0th degree polynomial\nFor non-polynomial mean, see ExternalDriftKriging\n\n\n\n\n\n","category":"type"},{"location":"kriging/estimators.html#External-Drift-Kriging","page":"Estimators","title":"External Drift Kriging","text":"","category":"section"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"In External Drift Kriging, the mean of the random field is assumed to be a combination of known smooth functions:","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"mu(x) = sum_k beta_k m_k(x)","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"Differently than Universal Kriging, the functions m_k are not necessarily polynomials of the spatial coordinates. In practice, they represent a list of variables that is strongly correlated (and co-located) with the variable being estimated.","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"External drifts are known to cause numerical instability. Give preference to other Kriging variants if possible.","category":"page"},{"location":"kriging/estimators.html","page":"Estimators","title":"Estimators","text":"ExternalDriftKriging","category":"page"},{"location":"kriging/estimators.html#KrigingEstimators.ExternalDriftKriging","page":"Estimators","title":"KrigingEstimators.ExternalDriftKriging","text":"ExternalDriftKriging(γ, drifts)\nExternalDriftKriging(X, z, γ, drifts)\n\nExternal Drift Kriging with variogram model γ and external drifts functions.\n\nOptionally, pass the coordinates X and values z to the fit function.\n\nNotes\n\nExternal drift functions should be smooth\nKriging system with external drift is often unstable\nInclude a constant drift (e.g. x->1) for unbiased estimation\nOrdinaryKriging is recovered for drifts = [x->1]\nFor polynomial mean, see UniversalKriging\n\n\n\n\n\n","category":"type"},{"location":"about/citing.html","page":"Citing","title":"Citing","text":"If you find GeoStats.jl useful in your work, please consider citing it:","category":"page"},{"location":"about/citing.html","page":"Citing","title":"Citing","text":"(Image: JOSS) (Image: DOI)","category":"page"},{"location":"about/citing.html","page":"Citing","title":"Citing","text":"@ARTICLE{Hoffimann2018,\n  title={GeoStats.jl – High-performance geostatistics in Julia},\n  author={Hoffimann, Júlio},\n  journal={Journal of Open Source Software},\n  publisher={The Open Journal},\n  volume={3},\n  pages={692},\n  number={24},\n  ISSN={2475-9066},\n  DOI={10.21105/joss.00692},\n  url={https://dx.doi.org/10.21105/joss.00692},\n  year={2018},\n  month={Apr}\n}","category":"page"},{"location":"index.html#GeoStats.jl","page":"Home","title":"GeoStats.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"An extensible framework for high-performance geostatistics in Julia.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage Status) (Image: Stable Documentation) (Image: Latest Documentation) (Image: License File)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Gitter) (Image: JOSS) (Image: DOI)","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"In many fields of science, such as mining engineering, hydrogeology, petroleum engineering, and environmental sciences, traditional statistical theories fail to provide unbiased estimates of resources due to the presence of spatial correlation. Geostatistics (a.k.a. spatial statistics) is the branch of statistics developed to overcome this limitation. Particularly, it is the branch that takes spatial coordinates of data into account.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"GeoStats.jl is an attempt to bring together bleeding-edge research in the geostatistics community into a comprehensive framework for spatial statistics, as well as to empower researchers and practioners with a toolkit for fast assessment of different modeling approaches.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The design of this project is the result of many years developing geostatistical software. I hope that it can serve to promote more collaboration between geostatisticians around the globe and to standardize this incredible science. If you would like to help support the project, please star the repository (Image: STARS) and share it with your colleagues. If you would like to extend the framework with new geostatistical solvers, please check the Developer guide.","category":"page"},{"location":"index.html#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"@ARTICLE{Hoffimann2018,\n  title={GeoStats.jl – High-performance geostatistics in Julia},\n  author={Hoffimann, Júlio},\n  journal={Journal of Open Source Software},\n  publisher={The Open Journal},\n  volume={3},\n  pages={692},\n  number={24},\n  ISSN={2475-9066},\n  DOI={10.21105/joss.00692},\n  url={https://dx.doi.org/10.21105/joss.00692},\n  year={2018},\n  month={Apr}\n}","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Get the latest stable release with Julia's package manager:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"] add GeoStats","category":"page"},{"location":"index.html#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A set of Jupyter notebooks demonstrating the current functionality of the project is available in GeoStatsTutorials with an accompanying series of videos:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<p align=\"center\">\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/yDIK9onnZVw\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</p>","category":"page"},{"location":"index.html#Quick-example","page":"Home","title":"Quick example","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Below is a quick preview of the high-level API:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using GeoStats\nusing Plots\ngr(size=(900,400)) # hide\n\n# list of properties with coordinates\nprops = (Z=[1.,0.,1.],)\ncoord = [(25.,25.), (50.,75.), (75.,50.)]\n\n# georeference data\n𝒟 = georef(props, coord)\n\n# estimation domain\n𝒢 = RegularGrid(100, 100)\n\n# estimation problem\nproblem = EstimationProblem(𝒟, 𝒢, :Z)\n\n# choose a solver from the list of solvers\nsolver = Kriging(\n  :Z => (variogram=GaussianVariogram(range=35.),)\n)\n\n# solve the problem\nsolution = solve(problem, solver)\n\n# plot the solution\ncontourf(solution, clabels=true)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For a more detailed example, please consult the Basic workflow section of the documentation.","category":"page"},{"location":"index.html#Project-organization","page":"Home","title":"Project organization","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The project is split into various packages:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Package Description\nGeoStats.jl Main package reexporting full stack of packages for geostatistics.\nVariography.jl Variogram estimation and modeling, and related tools.\nKrigingEstimators.jl High-performance implementations of Kriging estimators.\nGeoEstimation.jl Efficient solvers for spatial estimation (e.g. interpolation).\nGaussianSimulation.jl Efficient solvers for Gaussian process simulation.\nPointPatterns.jl Spatial point pattern analysis and synthesis.\nGeoStatsImages.jl Training images for multiple-point simulation.\nGslibIO.jl Utilities to read/write extended GSLIB files.\nGeoStatsBase.jl Base package containing core functionality.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The main GeoStats.jl package reexports the full stack of packages for high-performance geostatistics in Julia. Other packages like GeoStatsImages.jl can be installed for additional functionality. Besides the packages above, the project is extended via solver packages. These solvers are implemented independently of the main package for different geostatistical problems.","category":"page"},{"location":"statistics.html#Statistics","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"statistics.html","page":"Statistics","title":"Statistics","text":"The term spatial statistics can refer to statistics computed with samples collected in a spatial domain (a.k.a. spatial data), or to statistics computed with multiple realizations of a random field (a.k.a. ensemble).","category":"page"},{"location":"statistics.html#Data","page":"Statistics","title":"Data","text":"","category":"section"},{"location":"statistics.html","page":"Statistics","title":"Statistics","text":"The following statistics have spatial semantics (i.e. make use of spatial coordinates), and as such, approximate better spatial variables when compared to their non-spatial counterparts:","category":"page"},{"location":"statistics.html","page":"Statistics","title":"Statistics","text":"mean(::AbstractData)\nvar(::AbstractData)\nquantile(::AbstractData, ::Any)","category":"page"},{"location":"statistics.html#Statistics.mean-Tuple{AbstractData}","page":"Statistics","title":"Statistics.mean","text":"mean(sdata)\nmean(sdata, v)\nmean(sdata, v, s)\n\nSpatial mean of spatial data sdata. Optionally, specify the variable v and the block side s.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.var-Tuple{AbstractData}","page":"Statistics","title":"Statistics.var","text":"var(sdata)\nvar(sdata, v)\nvar(sdata, v, s)\n\nSpatial variance of spatial data sdata. Optionally, specify the variable v and the block side s.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.quantile-Tuple{AbstractData,Any}","page":"Statistics","title":"Statistics.quantile","text":"quantile(sdata, p)\nquantile(sdata, v, p)\nquantile(sdata, v, p, s)\n\nSpatial quantile of spatial data sdata at probability p. Optionally, specify the variable v and the block side s.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html","page":"Statistics","title":"Statistics","text":"A histogram with spatial semantics is also available where the heights of the bins are readjusted based on the coordinates of the samples (i.e. declustered histogram):","category":"page"},{"location":"statistics.html","page":"Statistics","title":"Statistics","text":"EmpiricalHistogram","category":"page"},{"location":"statistics.html#GeoStatsBase.EmpiricalHistogram","page":"Statistics","title":"GeoStatsBase.EmpiricalHistogram","text":"EmpiricalHistogram(sdata)\nEmpiricalHistogram(sdata, v)\nEmpiricalHistogram(sdata, v, s)\n\nSpatial histogram of spatial data sdata. Optionally, specify the variable v and the block side s.\n\n\n\n\n\n","category":"function"},{"location":"statistics.html#Ensemble","page":"Statistics","title":"Ensemble","text":"","category":"section"},{"location":"statistics.html","page":"Statistics","title":"Statistics","text":"A set of geostatistical realizations of a random field represents a probability distribution. It is often useful to compute summary statistics with this set or ensemble:","category":"page"},{"location":"statistics.html","page":"Statistics","title":"Statistics","text":"mean(::Ensemble)\nvar(::Ensemble)\nquantile(::Ensemble, ::Number)","category":"page"},{"location":"statistics.html#Statistics.mean-Tuple{Ensemble}","page":"Statistics","title":"Statistics.mean","text":"mean(ensemble)\n\nMean of ensemble.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.var-Tuple{Ensemble}","page":"Statistics","title":"Statistics.var","text":"var(ensemble)\n\nVariance of ensemble.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.quantile-Tuple{Ensemble,Number}","page":"Statistics","title":"Statistics.quantile","text":"quantile(ensemble, p)\n\np-quantile of ensemble.\n\n\n\n\n\n","category":"method"}]
}
